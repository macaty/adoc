
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="robots" content="index, follow">
<meta name='description' content='aardio 编程语言文档 - win.ui.ctrl.plus 库模块帮助文档'>
<meta http-equiv='content-language' content='zh-cn'>
<title>aardio 编程语言文档 - win.ui.ctrl.plus 库模块帮助文档</title> 
<link rel="stylesheet" href="../../../../css/markdown.css" tppabs="https://www.aardio.com/zh-cn/doc/css/markdown.css">
<script src="../../../../js/prism.js" tppabs="https://www.aardio.com/zh-cn/doc/js/prism.js"></script>
<link rel="stylesheet" href="../../../../../../../lib.baomitu.com/font-awesome/6.6.0/css/fontawesome.min.css" tppabs="https://lib.baomitu.com/font-awesome/6.6.0/css/fontawesome.min.css">
<link rel="stylesheet" href="../../../../../../../lib.baomitu.com/font-awesome/6.6.0/css/solid.min.css" tppabs="https://lib.baomitu.com/font-awesome/6.6.0/css/solid.min.css">
</head>
<body class="markdown-body"><a id="back-to-home" href="../../../../index.htm" tppabs="https://www.aardio.com/zh-cn/doc/" title="aardio 编程语言文档首页"><i class="fas fa-home" id="home-icon"></i><i class="fas fa-robot" id="ai-icon" style="display: none;"></i><span id="aardio-document-home">aardio 文档</span></a>
<h1>win.ui.ctrl.plus 库模块帮助文档</h1>

<p><a id="win.ui.ctrl"></a></p>

<h2>win.ui.ctrl 成员列表</h2>

<p><a id="win.ui.ctrl.plus"></a></p>

<h3>win.ui.ctrl.plus</h3>

<p>高级图像控件</p>

<p><a id="win.ui.ctrl.plus"></a></p>

<h3>win.ui.ctrl.plus()</h3>

<p>高级图像控件  </p>

<p><a href="plus.html#uiCtrlPlusObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/win/ui/ctrl/plus.html#uiCtrlPlusObject">返回对象:uiCtrlPlusObject</a></p>

<p><a id="uiCtrlPlusObject"></a></p>

<h2>uiCtrlPlusObject 成员列表</h2>

<p><a id="uiCtrlPlusObject._embedObject"></a></p>

<h3>uiCtrlPlusObject._embedObject</h3>

<p>嵌入 COM 控件的容器对象  </p>

<p><a href="../../../com/_.html#embedObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/com/_.html#embedObject">返回对象:embedObject</a></p>

<p><a id="uiCtrlPlusObject._parentForm"></a></p>

<h3>uiCtrlPlusObject._parentForm</h3>

<p>控件所在的父窗口(指win.form对象)  </p>

<p><a href="../_.html#winform" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/win/ui/_.html#winform">返回对象:winform</a></p>

<p><a id="uiCtrlPlusObject.addCtrl"></a></p>

<h3>uiCtrlPlusObject.addCtrl</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.addCtrl(  
    button={ cls=&quot;button&quot;;text=&quot;button&quot;;left=33;top=32;right=126;bottom=81;autoResize=false }    
)
</code></pre>

<p><a id="uiCtrlPlusObject.adjust"></a></p>

<h3>uiCtrlPlusObject.adjust</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.adjust = function( cx,cy,wParam ) {       
    /*窗口缩放时会自动触发此函数。  
cx 参数为窗口宽度,cy 参数为窗口高度,  
wParam 参数请参考 _WM_SIZE 消息参数说明,一般不用管。  

所有 win.form 创建的窗体和控件都支持此事件,  
重复赋值只会追加而不会覆盖此事件。  
一般不建议添加一个 wndproc 仅仅是为了处理  _WM_SIZE 消息，  
定义 adjust 事件是更好的选择。  

可主动调用此事件,省略参数时 cx,cy 参数默认设为窗口大小*/    
};
</code></pre>

<p><a id="uiCtrlPlusObject.align"></a></p>

<h3>uiCtrlPlusObject.align</h3>

<p>文本水平对齐,<br>
左对齐：&quot;left&quot;<br>
居中：&quot;center&quot;<br>
右对齐：&quot;right&quot;  </p>

<p>图标文本请使用 iconStyle 属性的 align 字段指定水平对齐</p>

<p><a id="uiCtrlPlusObject.animation"></a></p>

<h3>uiCtrlPlusObject.animation</h3>

<p>是否允许自动播放 GIF 动画，<br>
指定为 false 禁止自动播放</p>

<p><a id="uiCtrlPlusObject.animationId"></a></p>

<h3>uiCtrlPlusObject.animationId</h3>

<p>动画定时器ID<br>
不可改动，可用于判断动画是否启动</p>

<p><a id="uiCtrlPlusObject.animationState"></a></p>

<h3>uiCtrlPlusObject.animationState</h3>

<p>此属性表示动画当前状态值,值null或false表示动画已停止</p>

<p><a id="uiCtrlPlusObject.argbColor"></a></p>

<h3>uiCtrlPlusObject.argbColor</h3>

<p>ARGB格式字体颜色,支持半透明<br>
注意plus控件、GDI+都是ARGB格式数值表示颜色分量,即:0xAARRGGBB<br>
与RGB的分量顺序是反过来的</p>

<p><a id="uiCtrlPlusObject.autoResize"></a></p>

<h3>uiCtrlPlusObject.autoResize</h3>

<p>是否允许跟随父窗体自动缩放</p>

<p><a id="uiCtrlPlusObject.background"></a></p>

<h3>uiCtrlPlusObject.background</h3>

<p>背景图像或背景色,<br>
获取值是返回 gdip.bitmap 对象或 ARGB 格式颜色数值，<br>
赋值时可指定图像路径、资源路径、gdip.bitmap 对象、颜色值，<br>
颜色值使用0xAARRGGBB格式的数值。<br>
赋值时指定一个路径或资源路径控件将自动缓存使用频繁的图像<br>
内存图像建议使用setBackground函数指定缓存名  </p>

<p><a href="https://www.aardio.com/zh-cn/doc/library-reference/gdip/bitmap.html#gdipbitmapObject">返回对象:gdipbitmapObject</a></p>

<p><a id="uiCtrlPlusObject.backgroundColor"></a></p>

<h3>uiCtrlPlusObject.backgroundColor</h3>

<p>当前状态背景颜色,<br>
修改背景色建议设置 background 属性为数值即可，<br>
直接修改 backgroundColor 不会释放之前的背景图像且不会重绘</p>

<p><a id="uiCtrlPlusObject.bkBottom"></a></p>

<h3>uiCtrlPlusObject.bkBottom</h3>

<p>背景图expand模式下九宫格切图的底部切线</p>

<p><a id="uiCtrlPlusObject.bkLeft"></a></p>

<h3>uiCtrlPlusObject.bkLeft</h3>

<p>背景图expand模式下九宫格切图的左侧切线</p>

<p><a id="uiCtrlPlusObject.bkRight"></a></p>

<h3>uiCtrlPlusObject.bkRight</h3>

<p>背景图expand模式下九宫格切图的右侧切线<br>
如果控件显示为水平滑块控件,此属性用于预留滑块按钮大小</p>

<p><a id="uiCtrlPlusObject.bkTop"></a></p>

<h3>uiCtrlPlusObject.bkTop</h3>

<p>背景图expand模式下九宫格切图的顶部切线</p>

<p><a id="uiCtrlPlusObject.border"></a></p>

<h3>uiCtrlPlusObject.border</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.border = {color=0x805F9EA0;radius=11;width=2}/*使用一个表对象指定当前边框样式，  
支持的字段请参考窗体设计器中设置边框样式生成的代码，  
表的其他可用字段与 skin 函数指定的 border 样式相同，请参考范例。  
修改此属性不会触发重绘。  
可使用 predraw 或 redraw,redrawTransparent 等函数重绘*/
</code></pre>

<p><a id="uiCtrlPlusObject.bottom"></a></p>

<h3>uiCtrlPlusObject.bottom</h3>

<p>底部坐标</p>

<p><a id="uiCtrlPlusObject.capture"></a></p>

<h3>uiCtrlPlusObject.capture</h3>

<p>是否捕获全局鼠标消息</p>

<p><a id="uiCtrlPlusObject.changeInterval"></a></p>

<h3>uiCtrlPlusObject.changeInterval(定时器ID,间隔时间,回调函数)</h3>

<p>重新设置间隔时间或回调函数</p>

<p><a id="uiCtrlPlusObject.checked"></a></p>

<h3>uiCtrlPlusObject.checked</h3>

<p>该属性可用于切换选取状态</p>

<p><a id="uiCtrlPlusObject.className"></a></p>

<h3>uiCtrlPlusObject.className</h3>

<p>运行时类名</p>

<p><a id="uiCtrlPlusObject.clearInterval"></a></p>

<h3>uiCtrlPlusObject.clearInterval(定时器ID)</h3>

<p>删除定时器。<br>
参数如果为 null 则忽略不执行，<br>
否则定时器ID必须是 setInterval 函数或setTimeout函数的返回值。  </p>

<p>请注意如果定时器被删除，ID 可能被重新分配给其他定时器。<br>
在定时器回调函数中返回 0,false 以删除定时器是更稳妥的方式</p>

<p><a id="uiCtrlPlusObject.clearTimeout"></a></p>

<h3>uiCtrlPlusObject.clearTimeout(定时器ID)</h3>

<p>删除定时器。<br>
参数如果为 null 则忽略不执行，<br>
否则定时器ID必须是 setInterval 函数或setTimeout函 数的返回值。  </p>

<p>请注意如果定时器被删除，ID 可能被重新分配给其他定时器。<br>
在定时器回调函数中返回 0,false 以删除定时器是更稳妥的方式</p>

<p><a id="uiCtrlPlusObject.close"></a></p>

<h3>uiCtrlPlusObject.close()</h3>

<p>关闭控件窗口</p>

<p><a id="uiCtrlPlusObject.cls"></a></p>

<h3>uiCtrlPlusObject.cls</h3>

<p>设计时类名</p>

<p><a id="uiCtrlPlusObject.color"></a></p>

<h3>uiCtrlPlusObject.color</h3>

<p>RGB格式字体颜色,<br>
如果启用了编辑模式,可同步修改编辑框字体颜色,<br>
注意使用argbColor修改颜色不能同步修改编辑框颜色</p>

<p><a id="uiCtrlPlusObject.createEditBox"></a></p>

<h3>uiCtrlPlusObject.createEditBox(创建控件参数)</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.createEditBox(   
    vscroll = true;   
    hscroll = true;   
    multiline = true;  
);/*创建并启用透明背景的richedit文本编辑框，可用参数与窗体设计器相同，  
创建文本框时应用plus控件预设的字体、颜色、水平对齐方式，  
并且使用plus控件预设的内边距限制文本编辑框显示范围。  

可使用editBox属性访问此文本编辑框，  
可通过设置plus控件的editable属性显示或隐藏文本编辑框*/
</code></pre>

<p><a id="uiCtrlPlusObject.createEmbed"></a></p>

<h3>uiCtrlPlusObject.createEmbed</h3>

<p>创建嵌入控件,返回控件容器对象,<br>
容器对象的 _object 成员是创建的 COM 对象,<br>
容器对象可通过添加成员函数响应 COM 对象事件，<br>
容器对象的主要作用是充当访问 COM 对象的中间代理对象。<br>
通常使用 util.metaProperty 为容器对象添加属性元表，<br>
属性元表可拦截属性、函数调用并调用 _object 对象,  </p>

<p>createEmbedEx 返回的容器已添加默认代理以直接访问 COM 对象</p>

<p><a id="uiCtrlPlusObject.createEmbed"></a></p>

<h3>uiCtrlPlusObject.createEmbed()</h3>

<p><a href="../../../com/_.html#embedObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/com/_.html#embedObject">返回对象:embedObject</a></p>

<p><a id="uiCtrlPlusObject.createEmbed"></a></p>

<h3>uiCtrlPlusObject.createEmbed(clsId,embedObj)</h3>

<p>创建嵌入控件,返回控件容器对象,<br>
容器对象的 _object 成员是创建的 COM 对象,<br>
容器对象可通过添加成员函数响应 COM 对象事件，<br>
容器对象的主要作用是充当访问 COM 对象的中间代理对象,<br>
@clsId 指定控件 CLSID,<br>
可选在参数@2中指定 COM 对象绑定的容器对象  </p>

<p>此函数失败会抛出异常</p>

<p><a id="uiCtrlPlusObject.createEmbed"></a></p>

<h3>uiCtrlPlusObject.createEmbed(comObject,embedObj)</h3>

<p>嵌入 COM 控件,返回控件容器对象,<br>
容器对象的 _object 成员是传入的 COM 对象,<br>
容器对象可通过添加成员函数响应 COM 对象事件，<br>
容器对象的主要作用是充当访问 COM 对象的中间代理对象,<br>
@comObject 指定已创建成功的 COM 对象,<br>
可选在参数@2中指定 COM 对象绑定的容器对象  </p>

<p>此函数失败会抛出异常</p>

<p><a id="uiCtrlPlusObject.createEmbedEx"></a></p>

<h3>uiCtrlPlusObject.createEmbedEx</h3>

<p>创建嵌入控件,返回控件容器对象,<br>
容器对象的 _object 成员是创建的 COM 对象,<br>
容器对象可通过添加成员函数响应 COM 对象事件，<br>
容器对象的主要作用是充当访问 COM 对象的中间代理对象。<br>
此函数返回的容器已添加元表并创建代理以直接访问 COM 对象</p>

<p><a id="uiCtrlPlusObject.createEmbedEx"></a></p>

<h3>uiCtrlPlusObject.createEmbedEx()</h3>

<p><a href="../../../com/_.html#embedObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/com/_.html#embedObject">返回对象:embedObject</a></p>

<p><a id="uiCtrlPlusObject.createEmbedEx"></a></p>

<h3>uiCtrlPlusObject.createEmbedEx(clsId,embedObj)</h3>

<p>创建嵌入控件,返回控件容器对象,<br>
此函数返回的容器已添加元表并创建代理以直接访问 COM 对象,<br>
@clsId 指定控件 CLSID,如果控件不是自内存加载,<br>
则可省略 @clsId 并由 firstCoClassId函数自动获,<br>
可选在参数@2中指定 COM 对象绑定的容器对象  </p>

<p>此函数失败会抛出异常</p>

<p><a id="uiCtrlPlusObject.directDrawBackgroundOnly"></a></p>

<h3>uiCtrlPlusObject.directDrawBackgroundOnly()</h3>

<p>允许直接在背景窗口上画图<br>
并禁止控件在自己的窗口绘图</p>

<p><a id="uiCtrlPlusObject.disablePaint"></a></p>

<h3>uiCtrlPlusObject.disablePaint()</h3>

<p>禁用默认绘图操作</p>

<p><a id="uiCtrlPlusObject.disabled"></a></p>

<h3>uiCtrlPlusObject.disabled</h3>

<p>是否禁用</p>

<p><a id="uiCtrlPlusObject.disabledText"></a></p>

<h3>uiCtrlPlusObject.disabledText</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.disabledText = {&#39;\uF254&#39;;&#39;\uF251&#39;;&#39;\uF252&#39;;&#39;\uF253&#39;;&#39;\uF250&#39;;text=&#39;&#39;}/*指定文本时,禁用此控件,并显示指定文本,  
指定一个数组时,控件将创建动画逐帧显示数组里的文字图标,  
如果控件配置了iconStyle属性,则使用iconText属性显示数组内的文字图标,  
指定为null时,启用此控件,并恢复控件禁用之前的text、iconText属性*/
</code></pre>

<p><a id="uiCtrlPlusObject.dpiScale"></a></p>

<h3>uiCtrlPlusObject.dpiScale(x,y)</h3>

<p>将 @x,@y 表示的像素值乘以窗体当前 DPI 缩放倍数并返回,<br>
省略 @y 参数时仅返回 @x 转换后的值</p>

<p><a id="uiCtrlPlusObject.dpiScaleX"></a></p>

<h3>uiCtrlPlusObject.dpiScaleX</h3>

<p>窗口当前使用的DPI横坐标缩放系数,<br>
该值由界面系统自动维护，任何情况下都不应手动修改,  </p>

<p>这是一个以小数表示百分比的数，例如 1.25 表示 125%,<br>
窗口未使用缩放或未完成缩放初始化时，值可能为 null，<br>
如果要获取屏幕缩放设置应改用 gdi.getDpiScale 函数</p>

<p><a id="uiCtrlPlusObject.dpiScaleY"></a></p>

<h3>uiCtrlPlusObject.dpiScaleY</h3>

<p>窗口当前使用的DPI纵坐标缩放系数,<br>
该值由界面系统自动维护，任何情况下都不应手动修改,  </p>

<p>这是一个以小数表示百分比的数，例如 1.25 表示 125%,<br>
窗口未使用缩放或未完成缩放初始化时，值可能为 null，<br>
如果要获取屏幕缩放设置应改用 gdi.getDpiScale 函数</p>

<p><a id="uiCtrlPlusObject.drawToDevice"></a></p>

<h3>uiCtrlPlusObject.drawToDevice(hdc,x,y)</h3>

<p>输出控件图像到hdc参数指定的GDI绘图设备,<br>
x,y为输出坐标,如果绘图到父窗口,x,y参数可省略</p>

<p><a id="uiCtrlPlusObject.drawToGraphics"></a></p>

<h3>uiCtrlPlusObject.drawToGraphics(graphics,x,y)</h3>

<p>输出控件图像到hdc参数指定的GDI+画板,<br>
x,y为输出坐标,如果绘图到父窗口,x,y参数可省略</p>

<p><a id="uiCtrlPlusObject.editBox"></a></p>

<h3>uiCtrlPlusObject.editBox</h3>

<p>文本编辑框,此文本框也是一个win.ui.tracker对象,  </p>

<p><a href="#richeditObject">返回对象:richeditObject</a></p>

<p><a id="uiCtrlPlusObject.editState"></a></p>

<h3>uiCtrlPlusObject.editState</h3>

<p>允许共享内部编辑框的外观状态,不指定默认值为true,<br>
如果希望利用文本边距、前景边距等模拟分离按钮<br>
可将此值显示指定为false</p>

<p><a id="uiCtrlPlusObject.editable"></a></p>

<h3>uiCtrlPlusObject.editable</h3>

<p>是否允许编辑文本<br>
如果此值设为true则切换到可编辑模式,<br>
也可以指定要嵌入的编辑框的类名，例如&quot;edit&quot;,<br>
不指定类名则创建透明背景的richedit文本编辑框  </p>

<p>在首次切换到可编辑模式下创建文本框，<br>
并同步应用plus控件预设的字体、颜色、水平对齐方式，<br>
并使用plus控件预设的内边距限制文本编辑框显示范围。  </p>

<p>可使用editBox属性访问此文本编辑框，<br>
如果文本编辑框已创建，再次修改editable仅显示或隐藏文本编辑框</p>

<p><a id="uiCtrlPlusObject.enableDpiScaling"></a></p>

<h3>uiCtrlPlusObject.enableDpiScaling(false)</h3>

<p>禁用DPI自动缩放,<br>
不指定参数启用DPI自动缩放,默认已启用</p>

<p><a id="uiCtrlPlusObject.fitContent "></a></p>

<h3>uiCtrlPlusObject.fitContent ()</h3>

<p>控件调整大小调整到适应当前显示字数</p>

<p><a id="uiCtrlPlusObject.focusOnClick"></a></p>

<h3>uiCtrlPlusObject.focusOnClick</h3>

<p>设为false时禁止在单击控件时设置此控件为焦点控件</p>

<p><a id="uiCtrlPlusObject.font"></a></p>

<h3>uiCtrlPlusObject.font</h3>

<p>控件字体（LOGFONT 结构体），<br>
注意获取该属性总是返回新的 LOGFONT 对象，<br>
修改返回字体并不会更新控件字体，<br>
除非重新赋值。  </p>

<p>建议尽量优先使用 getFont 或 setFont 函数，<br>
以增强代码可读性  </p>

<p>字体会根据控件设置自动处理 DPI 缩放，不需要事先缩放字体大小</p>

<p><a id="uiCtrlPlusObject.fontCharMap"></a></p>

<h3>uiCtrlPlusObject.fontCharMap</h3>

<p>指定自定义字符映射表,<br>
键为字符,值为用于显示字符的gdip.bitmap对象<br>
如果指定了此属性则忽略字体大小,使用textPadding以及内边距限制输出大小</p>

<p><a id="uiCtrlPlusObject.foreBottom"></a></p>

<h3>uiCtrlPlusObject.foreBottom</h3>

<p>前景图expand模式下九宫格切图的底部切线</p>

<p><a id="uiCtrlPlusObject.foreLeft"></a></p>

<h3>uiCtrlPlusObject.foreLeft</h3>

<p>前景图expand模式下九宫格切图的左侧切线</p>

<p><a id="uiCtrlPlusObject.foreRepeat"></a></p>

<h3>uiCtrlPlusObject.foreRepeat</h3>

<p>前景显示模式<br>
支持模式expand,stretch,center,tile,scale<br>
如果为null则foreLeft,foreRight为偏移坐标\expand模式foreTop,foreRight,foreBottom,foreLeft为九宫格切图坐标<br>
其他模式为显示边距</p>

<p><a id="uiCtrlPlusObject.foreRight"></a></p>

<h3>uiCtrlPlusObject.foreRight</h3>

<p>前景图expand模式下九宫格切图的右侧切线</p>

<p><a id="uiCtrlPlusObject.foreTop"></a></p>

<h3>uiCtrlPlusObject.foreTop</h3>

<p>前景图expand模式下九宫格切图的顶部切线<br>
如果控件显示为垂直滑块控件,此属性用于预留滑块按钮大小</p>

<p><a id="uiCtrlPlusObject.foreground"></a></p>

<h3>uiCtrlPlusObject.foreground</h3>

<p>前景图像或前景色,<br>
获取值是返回 gdip.bitmap 对象或 ARGB 格式颜色数值，<br>
赋值时可指定图像路径、资源路径、gdip.bitmap 对象、颜色值，<br>
颜色值使用0xAARRGGBB格式的数值。<br>
赋值时指定一个路径或资源路径控件将自动缓存使用频繁的图像<br>
内存图像建议使用setForeground函数指定缓存名<br>
如果边框圆角设为-1,前景图或前景色会裁剪为圆形后输出,  </p>

<p><a href="https://www.aardio.com/zh-cn/doc/library-reference/gdip/bitmap.html#gdipbitmapObject">返回对象:gdipbitmapObject</a></p>

<p><a id="uiCtrlPlusObject.foregroundColor"></a></p>

<h3>uiCtrlPlusObject.foregroundColor</h3>

<p>当前状态前景颜色,<br>
修改背景色建议设置 foreground 属性为数值即可，<br>
直接修改 foregroundColor 不会释放之前的前景图像且不会重绘</p>

<p><a id="uiCtrlPlusObject.getBackground"></a></p>

<h3>uiCtrlPlusObject.getBackground()</h3>

<p>返回背景图像,返回值为gdip.bitmap对象<br>
此函数不会返回背景色，仅返回背景图像,<br>
如果不存在背景图像返回null  </p>

<p><a href="https://www.aardio.com/zh-cn/doc/library-reference/gdip/bitmap.html#gdipbitmapObject">返回对象:gdipbitmapObject</a></p>

<p><a id="uiCtrlPlusObject.getClientRect"></a></p>

<h3>uiCtrlPlusObject.getClientRect()</h3>

<p>控件客户区块位置(::RECT结构体)  </p>

<p><a href="../../../global/_.html#rectObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/global/_.html#rectObject">返回对象:rectObject</a></p>

<p><a id="uiCtrlPlusObject.getFont"></a></p>

<h3>uiCtrlPlusObject.getFont()</h3>

<p>返回控件 LOGFONT 字体，<br>
返回对象的 h 值会按控件的 DPI 缩放设置自动还原为缩放前大小。  </p>

<p><a href="#logfontObject">返回对象:logfontObject</a></p>

<p><a id="uiCtrlPlusObject.getFont"></a></p>

<h3>uiCtrlPlusObject.getFont(true)</h3>

<p>返回控件 LOGFONT 字体，<br>
返回对象的 h 值为字体实际大小，不会按控件 DPI 设置还原。<br>
返回字体会设置 noScale 属性为 true,<br>
使用控件的 setFont 函数或赋值 font 属性时，<br>
noScale 属性为 true 的字体同样不会进行自动 DPI 缩放  </p>

<p><a href="#logfontObject">返回对象:logfontObject</a></p>

<p><a id="uiCtrlPlusObject.getFontEx"></a></p>

<h3>uiCtrlPlusObject.getFontEx()</h3>

<p>返回gdip.font字体<br>
注意字体生命期由控件管理  </p>

<p><a href="https://www.aardio.com/zh-cn/doc/library-reference/gdip/font.html#gdipfontObject">返回对象:gdipfontObject</a></p>

<p><a id="uiCtrlPlusObject.getForeground"></a></p>

<h3>uiCtrlPlusObject.getForeground()</h3>

<p>返回前景图像,返回值为gdip.bitmap对象<br>
此函数不会返回前景色，仅返回前景图像,<br>
如果不存在前景图像返回null  </p>

<p><a href="https://www.aardio.com/zh-cn/doc/library-reference/gdip/bitmap.html#gdipbitmapObject">返回对象:gdipbitmapObject</a></p>

<p><a id="uiCtrlPlusObject.getForm"></a></p>

<h3>uiCtrlPlusObject.getForm()</h3>

<p>如果是窗体返回自身<br>
如果是控件则返回_parentForm  </p>

<p><a href="../_.html#winform" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/win/ui/_.html#winform">返回对象:winform</a></p>

<p>标准库中所有控件都拥有此同名函数用于返回控件所在窗口,<br>
窗口对象实现了同名函数用于返回窗口自身</p>

<p><a id="uiCtrlPlusObject.getParent"></a></p>

<h3>uiCtrlPlusObject.getParent()</h3>

<p>返回父窗口</p>

<p><a id="uiCtrlPlusObject.getPos"></a></p>

<h3>uiCtrlPlusObject.getPos()</h3>

<p>返回相对父窗口客户区的坐标,宽,高,<br>
参数为true返回屏幕坐标,宽,高,<br>
x,y,cx,cy=win.getPos(hwnd)</p>

<p><a id="uiCtrlPlusObject.getProgressRange"></a></p>

<h3>uiCtrlPlusObject.getProgressRange()</h3>

<p>返回进度条最小值,最大值</p>

<p><a id="uiCtrlPlusObject.getRect"></a></p>

<h3>uiCtrlPlusObject.getRect()</h3>

<p>控件区块位置(::RECT结构体)</p>

<p><a id="uiCtrlPlusObject.getRect"></a></p>

<h3>uiCtrlPlusObject.getRect(true)</h3>

<p>控件屏幕区块位置(::RECT结构体)</p>

<p><a id="uiCtrlPlusObject.getRoot"></a></p>

<h3>uiCtrlPlusObject.getRoot()</h3>

<p>获取顶层父窗口，这个函数会查找 orphanWindow 的父窗口</p>

<p><a id="uiCtrlPlusObject.height"></a></p>

<h3>uiCtrlPlusObject.height</h3>

<p>高度</p>

<p><a id="uiCtrlPlusObject.hide"></a></p>

<h3>uiCtrlPlusObject.hide</h3>

<p>当前控件窗口是否隐藏。<br>
仅检查当前窗口的可见性样式（窗口 是否移除了 _WS_VISIBLE 样式）。<br>
不考虑父窗口是否可见，不考虑是否被其他窗口遮挡。<br>
如果需要同时判断父窗口的可见性，应改用 win.isVisible 函数。</p>

<p><a id="uiCtrlPlusObject.hotkeyPrefix"></a></p>

<h3>uiCtrlPlusObject.hotkeyPrefix</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.hotkeyPrefix = _GdipHotkeyPrefixShow;
</code></pre>

<p><a id="uiCtrlPlusObject.hwnd"></a></p>

<h3>uiCtrlPlusObject.hwnd</h3>

<p>控件句柄</p>

<p><a id="uiCtrlPlusObject.iconColor"></a></p>

<h3>uiCtrlPlusObject.iconColor</h3>

<p>字体图标颜色,支持半透明,<br>
支持使用skin函数动态切换此样﻿式,<br>
此颜色存储为ARGB格式，即:0xAARRGGBB,注意在创建控件的初始化参数中必须传入RGB格式颜色值,  </p>

<p>请注意在未指定指属性时,图标字体默认与字体使用相同的颜色</p>

<p><a id="uiCtrlPlusObject.iconFont"></a></p>

<h3>uiCtrlPlusObject.iconFont</h3>

<p>图标字体，LOGFONT 结构体。<br>
获取值时，如果存在 iconStyle.font，直接返回 iconStyle.font。<br>
对 iconFont 赋值总是会创建新的 LOGFONT 结构并存为 iconStyle.font<br>
使用 iconFont 赋值时可以传入仅指定 LOGFONT 部分成员的普通表。  </p>

<p>修改返回字体的成员不会更新 plus 控件实际使用的 GDI+ 字体。<br>
只有重新对 iconFont 赋值 ，才会在下次重绘时刷新 GDI+ 字体  </p>

<p>图标字体会根据控件设置自动处理 DPI 缩放，不需要事先缩放字体大小  </p>

<p><a href="#logfontObject">返回对象:logfontObject</a></p>

<p><a id="uiCtrlPlusObject.iconStyle"></a></p>

<h3>uiCtrlPlusObject.iconStyle</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.iconStyle = {
    font=LOGFONT(h=-38;name=&#39;FontAwesome&#39;); 
    align=&quot;left&quot;;valign=&quot;top&quot;;padding={bottom=50}/*用于指定 iconText 显示样式  

如 font 指向控件已使用的 iconStyle.font，则控件不会刷新字体。  
font 如不是 ::LOGFONT 字体，控件将自动转换为 ::LOGFONT 字体。  
对 iconFont 属性赋值以修改 iconStyle.font 则总是会刷新字体*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.iconText"></a></p>

<h3>uiCtrlPlusObject.iconText</h3>

<p>指定文本图标<br>
使用iconStyle指定字体与样式</p>

<p><a id="uiCtrlPlusObject.iconTextRenderingHint"></a></p>

<h3>uiCtrlPlusObject.iconTextRenderingHint</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.iconTextRenderingHint = _GdipTextRenderingHint;
</code></pre>

<p><a id="uiCtrlPlusObject.id"></a></p>

<h3>uiCtrlPlusObject.id</h3>

<p>控件ID</p>

<p><a id="uiCtrlPlusObject.imageAttributes"></a></p>

<h3>uiCtrlPlusObject.imageAttributes</h3>

<p>可选使用一个gdip.imageAttributes对象对前景图像进行自动调色<br>
如果需要在不同状态下调色,可以在onStateChange事件里动态设置调色矩阵  </p>

<p><a href="#gdipImgattrObject">返回对象:gdipImgattrObject</a></p>

<p><a id="uiCtrlPlusObject.interpolationMode"></a></p>

<h3>uiCtrlPlusObject.interpolationMode</h3>

<p>图像缩放时的默认插值模式,<br>
默认值为_GdipInterpolationModeHighQualityBicubic</p>

<p><a id="uiCtrlPlusObject.invalidate(/*可选使用::RECT"></a></p>

<h3>uiCtrlPlusObject.invalidate(/*可选使用::RECT()对象指定客户区*/)</h3>

<p>使窗口绘图区无效</p>

<p><a id="uiCtrlPlusObject.invalidate(/*可选使用::RECT"></a></p>

<h3>uiCtrlPlusObject.invalidate(/*可选使用::RECT()对象指定客户区*/,0)</h3>

<p>使窗口绘图区无效<br>
不刷新背景</p>

<p><a id="uiCtrlPlusObject.isDialogMessage"></a></p>

<h3>uiCtrlPlusObject.isDialogMessage</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.isDialogMessage = function(hParent,msg){/*在控件范围内替代父窗口的 isDialogMessage，  
可用于在控件范围内屏蔽对话框快捷键*/}
</code></pre>

<p><a id="uiCtrlPlusObject.isForm"></a></p>

<h3>uiCtrlPlusObject.isForm</h3>

<p>标准库中所有控件以及窗体对象都拥有此同名函数<br>
窗体返回true,控件返回false</p>

<p><a id="uiCtrlPlusObject.isHyperlink"></a></p>

<h3>uiCtrlPlusObject.isHyperlink()</h3>

<p>控件不设置背景、前景<br>
但设置了显示文本,并启用事件回调则该值返回真</p>

<p><a id="uiCtrlPlusObject.left"></a></p>

<h3>uiCtrlPlusObject.left</h3>

<p>左侧坐标</p>

<p><a id="uiCtrlPlusObject.linearGradient"></a></p>

<h3>uiCtrlPlusObject.linearGradient</h3>

<p>数值,指定背景色线性渐变的角度,<br>
渐变从背色颜色开始,到前景颜色结束<br>
只有背景、前景都指定了当前状态下的颜色值才有效,<br>
270,90为垂直方向的渐变<br>
180,360为水平方向的渐变  </p>

<p>此属性指定为负数启用圆形径向渐变,此时background为中心颜色，foreground为环绕颜色</p>

<p><a id="uiCtrlPlusObject.measureString"></a></p>

<h3>uiCtrlPlusObject.measureString()</h3>

<p>返回文本输出后的区出大小,返回值为RECTF对象<br>
可选在参数中指定要输出的文本,不指定则取当前显示文本,  </p>

<p><a href="https://www.aardio.com/zh-cn/doc/library-reference/gdip/core.html#rectfObject">返回对象:rectfObject</a></p>

<p><a id="uiCtrlPlusObject.messageOnly"></a></p>

<h3>uiCtrlPlusObject.messageOnly()</h3>

<p>将窗口转换为message-only window<br>
该窗口不可见,仅用于消息分发</p>

<p><a id="uiCtrlPlusObject.modifyStyle"></a></p>

<h3>uiCtrlPlusObject.modifyStyle(remove,add,swpFlags)</h3>

<p>修改窗口样式,所有参数都是可选参数,<br>
@remove 用数值指定要移除的样式,可使用 <em>WS</em> 前缀的常量<br>
@add 用数值指定要添加的样式,可使用 <em>WS</em> 前缀的常量<br>
@swpFlags 可选用数值指定调整窗口选项,可使用 <em>SWP</em> 前缀的常量<br>
如果指定了 @swpFlag ,则使用该参数调用::SetWindowPos<br>
细节请参考 win.modifyStyle 函数源码</p>

<p><a id="uiCtrlPlusObject.modifyStyleEx"></a></p>

<h3>uiCtrlPlusObject.modifyStyleEx(remove,add,swpFlags)</h3>

<p>修改窗口扩展样式,所有参数都是可选参数,<br>
@remove 用数值指定要移除的样式,可使用 <em>WS_EX</em> 前缀的常量<br>
@add 用数值指定要添加的样式,可使用 <em>WS_EX</em> 前缀的常量<br>
@swpFlags 可选用数值指定调整窗口选项,可使用 <em>SWP</em> 前缀的常量<br>
如果指定了 @swpFlag ,则使用该参数调用::SetWindowPos<br>
细节请参考 win.modifyStyle 函数源码</p>

<p><a id="uiCtrlPlusObject.notify"></a></p>

<h3>uiCtrlPlusObject.notify</h3>

<p>是否启用事件回调<br>
设为false将不能响应鼠标按键等交互事件</p>

<p><a id="uiCtrlPlusObject.onAnimation"></a></p>

<h3>uiCtrlPlusObject.onAnimation(state,beginning,change,timestamp)</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onAnimation = function(state,beginning,change,timestamp){
    /*动画触发此函数,state 参数是上次返回的值  
可以使用plus控件的animationState属性获取这里的返回值,  
beginning,change为调用startAnimation指定的参数,  
timestamp 参数为动画已执行的时间,  
返回值为false或null停止动画*/
    return state
}
</code></pre>

<p><a id="uiCtrlPlusObject.onDrawBackground"></a></p>

<h3>uiCtrlPlusObject.onDrawBackground</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onDrawBackground = function(graphics,rc,bkColor,foreColor){
    /*自绘背景,  
graphics 为gdip.graphics对象(GDI+画板),  
rc为绘图区块,  
bkColor为当前状态背景色,AGGB格式,可能为null  
foreColor为当前状态前景色,ARGB格式,不会出现null值  
返回真取消默认的背景绘图*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onDrawContent"></a></p>

<h3>uiCtrlPlusObject.onDrawContent</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onDrawContent = function(graphics,rc,txtColor,rcContent,foreColor){
    /*自绘前景,  
graphics 为gdip.graphics对象(GDI+画板),  
txtColor 为文本色,ARGB 格式数值,  
foreColor 为当前状态前景色,ARGB 格式数值,  
rc为客户区RECT结构体,rcContent为去掉内边距后的RECT结构体,  
返回真取消绘制文本、前景等默认操作*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onDrawEnd"></a></p>

<h3>uiCtrlPlusObject.onDrawEnd</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onDrawEnd = function(graphics,rc,bmpMem){
    /*所有绘制操作结束触发此事件,  
graphics 为gdip.graphics对象(GDI+画板),  
rc 为客户区RECT结构体,  
bmpMem 为当前正在绘制的 gdip.bitmap 对象，  
要注意此函数退出后不可继续使用 bmpMem，  
可使用 bmpMem.clone,bmpMem.copy,bmpMem.getThumbnail 等复制图像*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onDrawForegroundEnd"></a></p>

<h3>uiCtrlPlusObject.onDrawForegroundEnd</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onDrawForegroundEnd = function(graphics,rc,rcContent){
    /*背景前景绘制后,绘制文本前触发此事件,  
graphics 为gdip.graphics对象(GDI+画板),  
rc为客户区RECT结构体,rcContent为去掉内边距后的RECT结构体*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onDrawString"></a></p>

<h3>uiCtrlPlusObject.onDrawString</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onDrawString = function(graphics,text,font,rectf,strformat,brush){
    /*自定义输出文本,请不要删除传入参数中的GDI+对象*/
    graphics.drawString(text,font,rectf,strformat,brush);
}
</code></pre>

<p><a id="uiCtrlPlusObject.onDropFiles"></a></p>

<h3>uiCtrlPlusObject.onDropFiles</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onDropFiles = function(files){  
    /*接受系统拖放,files是拖放的所有文件路径名数组,嵌入编辑框必须是edit控件,richedit*/  
}
</code></pre>

<p><a id="uiCtrlPlusObject.onFocusGot"></a></p>

<h3>uiCtrlPlusObject.onFocusGot(hLostFocus)</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onFocusGot = function(hLostFocus){
    ..win.setFocus(hLostFocus);/*得到焦点触发此事件,hLostFocus为失去焦点的窗口句柄,  
如果在这里将hLostFocus恢复焦点,则阻止当前窗口得到焦点*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onFocusLost"></a></p>

<h3>uiCtrlPlusObject.onFocusLost(hFocus)</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onFocusLost = function(hFocus){
    /*失去焦点触发此事件,hFocus为得到焦点的窗口句柄*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onKeyDown"></a></p>

<h3>uiCtrlPlusObject.onKeyDown</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onKeyDown = function(keyCode,lParam,repeat){
    /*按下键盘键*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onKeyUp"></a></p>

<h3>uiCtrlPlusObject.onKeyUp</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onKeyUp = function(keyCode,lParam){
    /*放开键盘键*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onMouseActivate"></a></p>

<h3>uiCtrlPlusObject.onMouseActivate</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onMouseActivate = function(hwndTop,hitTest,message){  
    return _MA_/*鼠标点击并且将要激活窗口时触发此事件  
hwndTop表示被激活的顶层窗口,  
hitTest参数请参考WM_NCHITTEST消息  
message为鼠标消息ID  
返回值的作用请参数MSDN*/  
}
</code></pre>

<p><a id="uiCtrlPlusObject.onMouseClick"></a></p>

<h3>uiCtrlPlusObject.onMouseClick</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onMouseClick = function(wParam,lParam){
    var x,y = win.getMessagePos(lParam);
    /*鼠标左键在控件上单击,  
orphanWindow模式下如果阻止控件得到焦点,此事件不会被触发*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onMouseDoubleClick"></a></p>

<h3>uiCtrlPlusObject.onMouseDoubleClick</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onMouseDoubleClick = function(wParam,lParam){
    var x,y = win.getMessagePos(lParam);
    /*鼠标左键双击*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onMouseDown"></a></p>

<h3>uiCtrlPlusObject.onMouseDown</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onMouseDown = function(wParam,lParam){
    var x,y = win.getMessagePos(lParam);
    /*鼠标左键按下,  
orphanWindow模式下如果阻止控件得到焦点,此事件不会被触发*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onMouseDrag"></a></p>

<h3>uiCtrlPlusObject.onMouseDrag</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onMouseDrag = function(wParam,lParam){
    /*鼠标左键按下拖动,  
自动捕获鼠标,允许拖出控件范围*/
}
</code></pre>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onMouseDrag = function(wParam,lParam){ 
    var x,y = win.getMessagePos(lParam);
    /*鼠标左键按下拖动,  
自动捕获鼠标,允许拖出控件范围*/ 
}
</code></pre>

<p><a id="uiCtrlPlusObject.onMouseEnter"></a></p>

<h3>uiCtrlPlusObject.onMouseEnter</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onMouseEnter = function(wParam,lParam){
    /*鼠标移入*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onMouseHWheel"></a></p>

<h3>uiCtrlPlusObject.onMouseHWheel</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onMouseHWheel = function(flags,delta,lParam){
    delta = -delta/(120/3); 
    /*水平滚动鼠标滚轮,flags 参数以 _MK_CONTROL 等常量表示按键*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onMouseHover"></a></p>

<h3>uiCtrlPlusObject.onMouseHover</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onMouseHover = function(wParam,lParam){
    /*鼠标悬停*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onMouseLeave"></a></p>

<h3>uiCtrlPlusObject.onMouseLeave</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onMouseLeave = function(wParam,lParam){
    /*鼠标移出*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onMouseMove"></a></p>

<h3>uiCtrlPlusObject.onMouseMove</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onMouseMove = function(wParam,lParam){
    if( wParam &amp; 0x1/*_MK_LBUTTON*/ ){
        var x,y = win.getMessagePos(lParam);
        /*鼠标移动*/
    }
}
</code></pre>

<p><a id="uiCtrlPlusObject.onMouseUp"></a></p>

<h3>uiCtrlPlusObject.onMouseUp</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onMouseUp = function(wParam,lParam){
    var x,y = win.getMessagePos(lParam);
    /*鼠标左键弹起*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onMouseWheel"></a></p>

<h3>uiCtrlPlusObject.onMouseWheel</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onMouseWheel = function(flags,delta,lParam){
    delta = delta/(120/3); 
    /*滚动鼠标滚轮,flags 参数以 _MK_CONTROL 等常量表示按键*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onPosChanged"></a></p>

<h3>uiCtrlPlusObject.onPosChanged</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onPosChanged = function( pos,triggeredByUser ){
    /*进度值变更,pos 参数为当前进度数值,  
如果此事件由用户拖动滑块或按键盘方向键触发,则 triggeredByUser 参数为 true*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onRightMouseDown"></a></p>

<h3>uiCtrlPlusObject.onRightMouseDown</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onRightMouseDown = function(wParam,lParam){
    var x,y = win.getMessagePos(lParam);
    /*鼠标右键按下*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onRightMouseUp"></a></p>

<h3>uiCtrlPlusObject.onRightMouseUp</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onRightMouseUp = function(wParam,lParam){
    var x,y = win.getMessagePos(lParam);
    /*鼠标右键弹起*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onSelectChange"></a></p>

<h3>uiCtrlPlusObject.onSelectChange</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onSelectChange = function(prev){
    /*单选模式下已选中当前控件,prev 为同一分组之前选中的控件  
同一分组之前没有选中控件时 prev 为 null*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onStateChange"></a></p>

<h3>uiCtrlPlusObject.onStateChange</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onStateChange = function(state){
    /*状态已改变*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onSysKeyDown"></a></p>

<h3>uiCtrlPlusObject.onSysKeyDown</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onSysKeyDown = function(keyCode,lParam,repeat){
    if(keyCode!=0x12/*_VK_ALT*/){
        /*按下键盘ALT组合键*/        
    }
}
</code></pre>

<p><a id="uiCtrlPlusObject.onSysKeyUp"></a></p>

<h3>uiCtrlPlusObject.onSysKeyUp</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onSysKeyUp = function(keyCode,lParam){
    /*放开键盘键*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.oncommand"></a></p>

<h3>uiCtrlPlusObject.oncommand</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.oncommand = function( id,event ){
    /*控件被单击*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.onnotify"></a></p>

<h3>uiCtrlPlusObject.onnotify</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.onnotify = function(id,code,ptr){
    /*处理通知消息,  
plus 控件默认不发送通知消息,  
但如果绑定 tooltip 控件这些会触发这个事件*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.orphanWindow"></a></p>

<h3>uiCtrlPlusObject.orphanWindow</h3>

<p>如果当前是子窗口,<br>
移除窗口的WS_CHILD样式，使窗口孤立出来悬浮于原位置,<br>
悬浮窗口如影随形的跟随父窗口移动或改变大小,控件原来的固定边距等参数仍然有效</p>

<p><a id="uiCtrlPlusObject.orphanWindow"></a></p>

<h3>uiCtrlPlusObject.orphanWindow(transparent,hwndBuddy)</h3>

<p>创建悬浮窗口,<br>
悬浮窗口仍然显示在原来的位置,<br>
可选参数 @transparent 如果为 true 则转换为分层透明窗口,<br>
可选利用 @buddy 参数将只有句柄的窗口托管在悬浮窗口之上实现相同的效果,<br>
伙伴窗口总是会保持在悬浮窗口前面，并保持相同的大小、位置</p>

<p><a id="uiCtrlPlusObject.paddingBottom"></a></p>

<h3>uiCtrlPlusObject.paddingBottom</h3>

<p>前景下边距<br>
可限制前景以及文本,文本还可以使用textPadding属性进一步增减边距  </p>

<p>滑块模式下,此属性将同时作用于背景色，作不会作用于背景图像</p>

<p><a id="uiCtrlPlusObject.paddingLeft"></a></p>

<h3>uiCtrlPlusObject.paddingLeft</h3>

<p>前景左边距<br>
可限制前景以及文本,文本还可以使用textPadding属性进一步增减边距  </p>

<p>滑块模式下,此属性将同时作用于背景色，作不会作用于背景图像</p>

<p><a id="uiCtrlPlusObject.paddingRight"></a></p>

<h3>uiCtrlPlusObject.paddingRight</h3>

<p>前景右边距<br>
可限制前景以及文本,文本还可以使用textPadding属性进一步增减边距  </p>

<p>滑块模式下,此属性将同时作用于背景色，作不会作用于背景图像</p>

<p><a id="uiCtrlPlusObject.paddingTop"></a></p>

<h3>uiCtrlPlusObject.paddingTop</h3>

<p>前景上边距<br>
可限制前景以及文本,文本还可以使用textPadding属性进一步增减边距  </p>

<p>滑块模式下,此属性将同时作用于背景色，作不会作用于背景图像</p>

<p><a id="uiCtrlPlusObject.passwordChar"></a></p>

<h3>uiCtrlPlusObject.passwordChar</h3>

<p>指定隐藏密码的占位字符,<br>
例如指定为&quot;*&quot;隐藏密码,指定为null正常显示文本<br>
如果调用了setCueBannerText，passwordChar不会影响提示文本</p>

<p><a id="uiCtrlPlusObject.postMessage"></a></p>

<h3>uiCtrlPlusObject.postMessage(msg,wParam,lParam)</h3>

<p>投递窗口消息到消息队列中<br>
此函数用法请参考 ::User32.PostMessage</p>

<p><a id="uiCtrlPlusObject.preadjust"></a></p>

<h3>uiCtrlPlusObject.preadjust</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.preadjust = function( cx,cy,wParam ) {    
    /*窗口缩放后重绘前、触发 adjust 事件之前触发此事件。  
所有 win.form 创建的窗体和控件都支持此事件,  
与 adjust 事件不同，对 preadjust 重复赋值则覆盖而不是追加事件。   

cx 参数为窗口宽度,cy 参数为窗口高度,  
wParam 为 _WM_SIZE 消息参数。*/    
};
</code></pre>

<p><a id="uiCtrlPlusObject.predraw"></a></p>

<h3>uiCtrlPlusObject.predraw()</h3>

<p>刷新位图缓存并准备下次重绘</p>

<p><a id="uiCtrlPlusObject.progressPercentage"></a></p>

<h3>uiCtrlPlusObject.progressPercentage</h3>

<p>进度条当前百分比。<br>
如果用户正在控件上按下鼠标（例如拖动滑块），设置此属性会被忽略</p>

<p><a id="uiCtrlPlusObject.progressPos"></a></p>

<h3>uiCtrlPlusObject.progressPos</h3>

<p>获取或设置进度条当前值。<br>
如果用户正在控件上按下鼠标（例如拖动滑块），设置此属性会被忽略</p>

<p><a id="uiCtrlPlusObject.publish"></a></p>

<h3>uiCtrlPlusObject.publish(&quot;字符串参数&quot;,)</h3>

<p>在窗口所在界面线程发布消息,<br>
运行界面线程所有所有调用subscribe函数订阅此消息的函数,<br>
可添加任意个触发参数</p>

<p><a id="uiCtrlPlusObject.radioClick"></a></p>

<h3>uiCtrlPlusObject.radioClick()</h3>

<p>单选模式下选中控件</p>

<p><a id="uiCtrlPlusObject.radioGroup"></a></p>

<h3>uiCtrlPlusObject.radioGroup</h3>

<p>用于指定单选按钮分组名称<br>
也可以在skin函数的group属性中指定该值</p>

<p><a id="uiCtrlPlusObject.radioValue"></a></p>

<h3>uiCtrlPlusObject.radioValue()</h3>

<p>单选模式下选中控件的文本</p>

<p><a id="uiCtrlPlusObject.redraw"></a></p>

<h3>uiCtrlPlusObject.redraw()</h3>

<p>刷新重绘<br>
不重绘背景,速度较快</p>

<p><a id="uiCtrlPlusObject.redrawTransparent"></a></p>

<h3>uiCtrlPlusObject.redrawTransparent()</h3>

<p>刷新重绘<br>
如果控件添加了透明样式 _WS_EX_TRANSPARENT 则重绘窗口背景</p>

<p><a id="uiCtrlPlusObject.reduce"></a></p>

<h3>uiCtrlPlusObject.reduce(array,callback,debounce)</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.reduce(  
    {/*@array 参数指定要循环处理每个元素的数组或表。  
@array 指定为 false 则取消之前创建的防抖单例循环。  

@callback 指定回调函数。  
回调函数中可返回本次间隔延时，以毫秒为单位。  
返回 0、null、false、以及不能转换为非 0 数的值中断处理。  
回调参数为下一个元素的值和索引,处理到数组尾部时回调参数为 null,  
如果此时仍然返回可转换为非 0 数的值,将转到第一个数组元素重复循环  
@callback 指定回调函数。  

@debounce 指定是否创建为防抖单例循环，默认为 true。*/},  
    function(value,index){  
        if(value){  
            return 50  
        }  
    }   
)
</code></pre>

<p><a id="uiCtrlPlusObject.reloadScale"></a></p>

<h3>uiCtrlPlusObject.reloadScale()</h3>

<p>按设计时位置参数、重新调整控件位置以适应窗口当前缩放比例。<br>
父窗口缩放时会自动执行此操作。<br>
默认在启动窗口消息循环时会自适应调整所有控件。<br>
所以在启动消息循环前添加控件不必调用此函数。</p>

<p><a id="uiCtrlPlusObject.repeat"></a></p>

<h3>uiCtrlPlusObject.repeat</h3>

<p>背景显示模式<br>
支持模式expand,stretch,center,tile,scale\expand模式foreTop,foreRight,foreBottom,foreLeft为九宫格切图坐标<br>
其他模式为显示边距</p>

<p><a id="uiCtrlPlusObject.resize"></a></p>

<h3>uiCtrlPlusObject.resize(宽度,高度)</h3>

<p>如果指定了参数则调整窗口大小,<br>
无论是否实际调整窗口大小,发送 _WM_SIZE 消息给窗口</p>

<p><a id="uiCtrlPlusObject.right"></a></p>

<h3>uiCtrlPlusObject.right</h3>

<p>右侧坐标</p>

<p><a id="uiCtrlPlusObject.saveScale"></a></p>

<h3>uiCtrlPlusObject.saveScale()</h3>

<p>根据控件当前位置、缩放比例，更新控件的设计时位置参数。<br>
以避免下次窗口缩放自适应调整控件当前位置更改被清除，<br>
控件所有调整位置的属性或成员函数已自动调用此函数。</p>

<p><a id="uiCtrlPlusObject.sendMessage"></a></p>

<h3>uiCtrlPlusObject.sendMessage(msg,wParam,lParam)</h3>

<p>发送窗口消息<br>
此函数用法请参考 ::User32.SendMessage</p>

<p><a id="uiCtrlPlusObject.setBackground"></a></p>

<h3>uiCtrlPlusObject.setBackground</h3>

<p>修改背景图像</p>

<p><a id="uiCtrlPlusObject.setBackground"></a></p>

<h3>uiCtrlPlusObject.setBackground()</h3>

<p><a href="https://www.aardio.com/zh-cn/doc/library-reference/gdip/bitmap.html#gdipbitmapObject">返回对象:gdipbitmapObject</a></p>

<p><a id="uiCtrlPlusObject.setBackground"></a></p>

<h3>uiCtrlPlusObject.setBackground(背景图像,false)</h3>

<p>加载背景图像并禁用缓存<br>
该函数设置成功返回原来的背景图（gdip.bitmap 对象）</p>

<p><a id="uiCtrlPlusObject.setBackground"></a></p>

<h3>uiCtrlPlusObject.setBackground(背景图像,缓存名,刷新重绘)</h3>

<p>参数@1也可以使用0xAARRGGBB格式的数值指定一个颜色值,<br>
缓存名为可选参数,默认以路径为缓存名,设为false禁止缓存,<br>
如果参数@1是图像数据则可以使用参数@2指定缓存名<br>
刷新重绘参数@3默认为true<br>
该函数设置成功返回原来的背景图（gdip.bitmap 对象）</p>

<p><a id="uiCtrlPlusObject.setCueBannerText"></a></p>

<h3>uiCtrlPlusObject.setCueBannerText</h3>

<p>并且指定嵌入编辑框为空时的显示的默认提示文本<br>
嵌入richedit时调用此函数会阻止拖放文件消息,<br>
嵌入编辑框改为edit即可</p>

<p><a id="uiCtrlPlusObject.setCueBannerText"></a></p>

<h3>uiCtrlPlusObject.setCueBannerText(&quot;提示文本&quot;)</h3>

<p>打开编辑模式,<br>
并且指定文本为空时的显示的默认提示文本<br>
注意指定提示文本以后,<br>
不应再直接访问editBox的text,passwordChar属性,<br>
请改为读写plus控件的text,passwordChar属性</p>

<p><a id="uiCtrlPlusObject.setFocus"></a></p>

<h3>uiCtrlPlusObject.setFocus()</h3>

<p>设置焦点<br>
可选在参数中指定新的控件文本<br>
如果启用了编辑模式,此函数将光标移动文本尾部</p>

<p><a id="uiCtrlPlusObject.setFont"></a></p>

<h3>uiCtrlPlusObject.setFont(指定字体)</h3>

<p>指定 LOGFONT 字体对象,或逻辑字体句柄<br>
如果不指定 point 值并指定 h 值，字体会按控件的 DPI 缩放设置自动缩放。</p>

<p><a id="uiCtrlPlusObject.setFont"></a></p>

<h3>uiCtrlPlusObject.setFont(混入字体属性)</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.setFont(h=-12;name=&quot;Tahoma&quot;);
</code></pre>

<p><a id="uiCtrlPlusObject.setFontEx"></a></p>

<h3>uiCtrlPlusObject.setFontEx(字体)</h3>

<p>设置gdip.font字体<br>
字体由控件接管并负责释放</p>

<p><a id="uiCtrlPlusObject.setForeRepeat"></a></p>

<h3>uiCtrlPlusObject.setForeRepeat(&quot;模式&quot;,是否重绘)</h3>

<p>修改前景显示模式<br>
支持模式expand,stretch,center,tile,scale</p>

<p><a id="uiCtrlPlusObject.setForeground"></a></p>

<h3>uiCtrlPlusObject.setForeground</h3>

<p>修改前景图像</p>

<p><a id="uiCtrlPlusObject.setForeground"></a></p>

<h3>uiCtrlPlusObject.setForeground()</h3>

<p><a href="https://www.aardio.com/zh-cn/doc/library-reference/gdip/bitmap.html#gdipbitmapObject">返回对象:gdipbitmapObject</a></p>

<p><a id="uiCtrlPlusObject.setForeground"></a></p>

<h3>uiCtrlPlusObject.setForeground(前景图像,缓存名,刷新重绘)</h3>

<p>修改前景图像<br>
参数@1也可以使用0xAARRGGBB格式的数值指定一个颜色值,<br>
缓存名为可选参数,默认以路径为缓存名,设为false禁止缓存,<br>
如果参数@1是图像数据则可以使用参数@2指定缓存名<br>
刷新重绘参数@3默认为true<br>
该函数设置成功返回原来的前景图图（gdip.bitmap 对象）</p>

<p><a id="uiCtrlPlusObject.setForeground"></a></p>

<h3>uiCtrlPlusObject.setForeground(背景图像,false)</h3>

<p>加载前景图像并禁用缓存<br>
该函数设置成功返回原来的背景图（gdip.bitmap 对象）</p>

<p><a id="uiCtrlPlusObject.setForeground"></a></p>

<h3>uiCtrlPlusObject.setForeground(颜色数值)</h3>

<p>修改foregroundColor的值<br>
注意plus控件、GDI+都是ARGB格式数值表示颜色分量,即:0xAARRGGBB<br>
与RGB的分量顺序是反过来的</p>

<p><a id="uiCtrlPlusObject.setInterval"></a></p>

<h3>uiCtrlPlusObject.setInterval(回调函数,延时毫秒数,...)</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.setInterval(回调函数,延时毫秒数,...setInterval(   
    function(){  
        /*参数@1指定执行函数,参数@2指定执行间隔，  
可选指定一个或多个回调参数，不指定回调参数则默认为:  
 hwnd,message,timerId,tick,  

如果在定时器中执行了win.delay等继续消息循环的代码，  
在定时器退出前不会再触发同一定时器（重入）。  

定时器回调函数返回数值可修改时间间隔,  
返回false取消该定时器*/  
    },1000   
)
</code></pre>

<p><a id="uiCtrlPlusObject.setParent"></a></p>

<h3>uiCtrlPlusObject.setParent(控件对象)</h3>

<p>改变父窗口</p>

<p><a id="uiCtrlPlusObject.setPieRange"></a></p>

<h3>uiCtrlPlusObject.setPieRange</h3>

<p>设置扇形进度条范围,</p>

<p><a id="uiCtrlPlusObject.setPieRange"></a></p>

<h3>uiCtrlPlusObject.setPieRange(最小值,最大值)</h3>

<p>切换为扇形进度条模式<br>
在此模式下前景图或前景色被裁剪为扇形,<br>
如果有背景色则被裁剪为圆角,背景图不裁剪,<br>
如果指定背景图、前景图,应设为center显示模式以使圆心对齐</p>

<p><a id="uiCtrlPlusObject.setPos"></a></p>

<h3>uiCtrlPlusObject.setPos(x坐标,y坐标,宽,高,插入位置,参数)</h3>

<p>调整窗口位置或排序,所有参数可选<br>
同时指定x,y坐标则移动位置<br>
同时指定宽高则改变大小<br>
指定插入位置(句柄或_HWND前缀常量)则调整Z序</p>

<p><a id="uiCtrlPlusObject.setProgressRange"></a></p>

<h3>uiCtrlPlusObject.setProgressRange</h3>

<p>设置进度条范围，并切换到进度条显示模式。<br>
如果宽大于高显示为水平进度条，高大于宽则显示为垂直进度条。<br>
调用了此函数将会强制使用expand显示模式<br>
水平进度条文本右对齐,垂直进度条文本上对齐时将限制文本输出于前景内部<br>
否则不改变文本输出位置<br>
可选用textPadding属性指定文本内边距</p>

<p><a id="uiCtrlPlusObject.setProgressRange"></a></p>

<h3>uiCtrlPlusObject.setProgressRange(最小值,最大值)</h3>

<p>设置进度条范围<br>
调用了此函数将会强制使用expand显示模式</p>

<p><a id="uiCtrlPlusObject.setRect"></a></p>

<h3>uiCtrlPlusObject.setRect(rc)</h3>

<p>设置控件区块位置(::RECT结构体)</p>

<p><a id="uiCtrlPlusObject.setRect"></a></p>

<h3>uiCtrlPlusObject.setRect(rc,true)</h3>

<p>设置控件屏幕区块位置(::RECT结构体)</p>

<p><a id="uiCtrlPlusObject.setRedraw"></a></p>

<h3>uiCtrlPlusObject.setRedraw(false)</h3>

<p>禁止重绘</p>

<p><a id="uiCtrlPlusObject.setRedraw"></a></p>

<h3>uiCtrlPlusObject.setRedraw(true)</h3>

<p>恢复重绘</p>

<p><a id="uiCtrlPlusObject.setRepeat"></a></p>

<h3>uiCtrlPlusObject.setRepeat(&quot;模式&quot;,是否重绘)</h3>

<p>修改背景显示模式<br>
支持模式expand,stretch,center,tile,scale</p>

<p><a id="uiCtrlPlusObject.setTimeout"></a></p>

<h3>uiCtrlPlusObject.setTimeout(函数或代码,延时,其他附加参数)</h3>

<p>推迟执行指定的函数或代码<br>
此函数异步执行参数中指定的函数，不会阻塞当前代码继续执行，<br>
延时参数是可选参数，以毫秒为单位，默认为0毫秒<br>
可选用附加参数指定调用延时函数的实参<br>
返回值为定时器ID</p>

<p><a id="uiCtrlPlusObject.setTrackbarRange"></a></p>

<h3>uiCtrlPlusObject.setTrackbarRange</h3>

<p>设置滑块范围，并切换到滑块显示模式。<br>
如果宽大于高显示为水平滑块，高大于宽则显示为垂直滑块。<br>
用户拖动滑块时触发 onPosChanged 事件，可用于获取当前位置</p>

<p><a id="uiCtrlPlusObject.setTrackbarRange"></a></p>

<h3>uiCtrlPlusObject.setTrackbarRange(最小值,最大值)</h3>

<p>如果使用图像制作滑块控件,<br>
请将背景、前景图像设为九宫格拉伸的expand模式,<br>
使用前景切图在右侧或顶部预留滑块位置不拉伸,<br>
如果未指定前景图像,aardio将自动使用当前字体颜色绘制滑块按钮,<br>
同样通过前景切图预留滑块大小,边框圆角属性将作用于滑块按钮,<br>
前景色将用于绘制滑块左侧或底部,背景色将用于绘制滑块右侧或顶部,<br>
前景边距将同时限制背景前景色的大小，但不会作用于背景图像</p>

<p><a id="uiCtrlPlusObject.show"></a></p>

<h3>uiCtrlPlusObject.show(true)</h3>

<p>显示控件</p>

<p><a id="uiCtrlPlusObject.skin"></a></p>

<h3>uiCtrlPlusObject.skin(样式表,是否禁止共享样式)</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.skin({  
    foreground = {   
        hover = &quot;/res/images/button-hover.png&quot;;  
        focus = &quot;/res/images/button-focus.png&quot;;  
        active = &quot;/res/images/button-active.png&quot;;  
        disabled = 0xFFCCCCCC;   
    };  
    color = {  
        hover = 0xF00000FF;/*用格式为0xAARRGGBB的16进制数值,指定鼠标放到控件上的字体颜色,  
AA为透明度,RR为红色分量,GG为绿色分量,BB为蓝色分量*/   
    };  
    border = {   
        hover = {left=5;color=0xFFFF0000;padding=15;}   
    };   
})
</code></pre>

<p><a id="uiCtrlPlusObject.smoothingMode"></a></p>

<h3>uiCtrlPlusObject.smoothingMode</h3>

<p>绘图画布默认抗锯齿模式,<br>
默认值为_GdipSmoothingModeAntiAlias</p>

<p><a id="uiCtrlPlusObject.startAnimation"></a></p>

<h3>uiCtrlPlusObject.startAnimation</h3>

<p>启动动画定时器,<br>
可以在控件的onAnimation动画事件函数中修改外观,<br>
或者在控件的onDrawContent等绘图事件函数中直接输出动画</p>

<p><a id="uiCtrlPlusObject.startAnimation"></a></p>

<h3>uiCtrlPlusObject.startAnimation(interval,beginning,change)</h3>

<p>启动动画定时器,<br>
interval参数指定动画时间间隔，以毫秒为单位,<br>
@beginning 指定初始状态值,@change 指定动画完成后的状态值,<br>
可选参数 @beginning,@change 会传给 onAnimation 回调函数作为调用参数</p>

<p><a id="uiCtrlPlusObject.startProgress"></a></p>

<h3>uiCtrlPlusObject.startProgress()</h3>

<p>启动进度条动画,并显示进度条,<br>
可选用参数@1指定间隔毫秒,可选用参数@2指定每次推进的进度<br>
必须调用setProgressRange函数事先指定进度范围<br>
必须指定前景色、或前景图</p>

<p><a id="uiCtrlPlusObject.stepProgress"></a></p>

<h3>uiCtrlPlusObject.stepProgress</h3>

<p>增加进度条的值</p>

<p><a id="uiCtrlPlusObject.stepProgress"></a></p>

<h3>uiCtrlPlusObject.stepProgress(步进单位,是否刷新)</h3>

<p>步进单位可以省略,默认为1<br>
参数@2可省略,默认为true<br>
进度条到尾部或头部则返回false,否则返回true</p>

<p><a id="uiCtrlPlusObject.stopAnimation"></a></p>

<h3>uiCtrlPlusObject.stopAnimation()</h3>

<p>停止动画定时器</p>

<p><a id="uiCtrlPlusObject.stopProgress"></a></p>

<h3>uiCtrlPlusObject.stopProgress()</h3>

<p>停止进度条动画,并隐藏进度条</p>

<p><a id="uiCtrlPlusObject.stringFormatFlags"></a></p>

<h3>uiCtrlPlusObject.stringFormatFlags</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.stringFormatFlags = _GdipStringFormatFlagsMeasureTrailingSpaces;
</code></pre>

<p><a id="uiCtrlPlusObject.tabNext"></a></p>

<h3>uiCtrlPlusObject.tabNext()</h3>

<p><a href="static.html#staticObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/win/ui/ctrl/static.html#staticObject">返回对象:staticObject</a></p>

<p><a id="uiCtrlPlusObject.tabNext"></a></p>

<h3>uiCtrlPlusObject.tabNext(移动焦点,是否反向)</h3>

<p>获取下一个支持tab控制焦点的控件<br>
参数@1为true会自动移动焦点到该控件<br>
参数@2为true则获取上一个控件,否则获取下一个控件</p>

<p><a id="uiCtrlPlusObject.text"></a></p>

<h3>uiCtrlPlusObject.text</h3>

<p>控件文本</p>

<p><a id="uiCtrlPlusObject.textPadding"></a></p>

<h3>uiCtrlPlusObject.textPadding</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.textPadding = {
    left = 0;
    top = 0;
    bottom = 0;
    right = 0;/*指定文本输出内边距,在前景内边距上叠加,可以使用负数,仅对文本有效*/
}
</code></pre>

<p><a id="uiCtrlPlusObject.textRenderingHint"></a></p>

<h3>uiCtrlPlusObject.textRenderingHint</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.textRenderingHint = _GdipTextRenderingHint;
</code></pre>

<p><a id="uiCtrlPlusObject.theme"></a></p>

<h3>uiCtrlPlusObject.theme</h3>

<p>外观主题,例如<br>
winform.button.theme = &quot;Explorer&quot;<br>
winform.button.theme = false</p>

<p><a id="uiCtrlPlusObject.threadCallable"></a></p>

<h3>uiCtrlPlusObject.threadCallable()</h3>

<p>开启此控件的跨线程调用功能</p>

<p><a id="uiCtrlPlusObject.top"></a></p>

<h3>uiCtrlPlusObject.top</h3>

<p>顶部坐标</p>

<p><a id="uiCtrlPlusObject.translateAccelerator"></a></p>

<h3>uiCtrlPlusObject.translateAccelerator</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.translateAccelerator = function(msg){   
    /*返回是否快捷键*/  
}
</code></pre>

<p><a id="uiCtrlPlusObject.translateCommand"></a></p>

<h3>uiCtrlPlusObject.translateCommand()</h3>

<p>允许转发转发子窗口的命令（_WM_COMMAND）与通知（_WM_NOTIFY）消息，<br>
避免子窗口 oncommand，onnotify 等回调失效。<br>
同时会处理子窗口的 _WM_CTLCOLORSTATIC 等消息，<br>
以避免部分外观属性失。  </p>

<p>启用嵌入编辑框功能时已自动调用此函数</p>

<p><a id="uiCtrlPlusObject.trimming"></a></p>

<h3>uiCtrlPlusObject.trimming</h3>

<pre><code class="aardio language-aardio">uiCtrlPlusObject.trimming = _GdipStringTrimming;
</code></pre>

<p><a id="uiCtrlPlusObject.tryCreateEmbed"></a></p>

<h3>uiCtrlPlusObject.tryCreateEmbed</h3>

<p>创建嵌入控件,返回控件容器对象,<br>
容器对象的 _object 成员是创建的 COM 对象,<br>
容器对象可通过添加成员函数响应 COM 对象事件，<br>
容器对象的主要作用是充当访问 COM 对象的中间代理对象。<br>
通常使用 util.metaProperty 为容器对象添加属性元表，<br>
属性元表可拦截属性、函数调用并调用 _object 对象,  </p>

<p>createEmbedEx 返回的容器已添加默认代理以直接访问 COM 对象</p>

<p><a id="uiCtrlPlusObject.tryCreateEmbed"></a></p>

<h3>uiCtrlPlusObject.tryCreateEmbed()</h3>

<p><a href="../../../com/_.html#embedObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/com/_.html#embedObject">返回对象:embedObject</a></p>

<p><a id="uiCtrlPlusObject.tryCreateEmbed"></a></p>

<h3>uiCtrlPlusObject.tryCreateEmbed(clsId,embedObj)</h3>

<p>创建嵌入控件,返回控件容器对象,<br>
容器对象的 _object 成员是创建的 COM 对象,<br>
容器对象可通过添加成员函数响应 COM 对象事件，<br>
容器对象的主要作用是充当访问 COM 对象的中间代理对象,<br>
@clsId 指定控件 CLSID,<br>
可选在参数@2中指定 COM 对象绑定的容器对象  </p>

<p>成功返回容器对象,失败返回false,错误信息</p>

<p><a id="uiCtrlPlusObject.update"></a></p>

<h3>uiCtrlPlusObject.update()</h3>

<p>重绘invalidate函数指定的区块</p>

<p><a id="uiCtrlPlusObject.valid"></a></p>

<h3>uiCtrlPlusObject.valid</h3>

<p>窗口是否有效，<br>
窗口未关闭返回 true ，<br>
窗口已关闭或正在关闭返回 false</p>

<p><a id="uiCtrlPlusObject.valign"></a></p>

<h3>uiCtrlPlusObject.valign</h3>

<p>文本垂直对齐,<br>
顶对齐：&quot;top&quot;<br>
居中：&quot;center&quot;<br>
底对齐：&quot;bottom&quot;  </p>

<p>图标文本对齐请使用 iconStyle 属性的 align 字段指定垂直对齐</p>

<p><a id="uiCtrlPlusObject.width"></a></p>

<h3>uiCtrlPlusObject.width</h3>

<p>宽度</p>

<p><a id="uiCtrlPlusObject.x"></a></p>

<h3>uiCtrlPlusObject.x</h3>

<p>前景x坐标,仅用于point绘图模式,<br>
1、0到1之间的小数表示百分比，负数表示右侧反向坐标</p>

<p><a id="uiCtrlPlusObject.y"></a></p>

<h3>uiCtrlPlusObject.y</h3>

<p>前景y坐标,仅用于point绘图模式,<br>
1、0到1之间的小数表示百分比，负数表示底部反向坐标</p>

<p><a id="uiCtrlPlusObject.state"></a></p>

<h2>uiCtrlPlusObject.state 成员列表</h2>

<p><a id="uiCtrlPlusObject.state.active"></a></p>

<h3>uiCtrlPlusObject.state.active</h3>

<p>鼠标或键盘键按下状态<br>
注意直接修改该状态控件不负责重绘</p>

<p><a id="uiCtrlPlusObject.state.checked"></a></p>

<h3>uiCtrlPlusObject.state.checked</h3>

<p>是否选中状态<br>
注意直接修改该状态控件不负责重绘</p>

<p><a id="uiCtrlPlusObject.state.disabled"></a></p>

<h3>uiCtrlPlusObject.state.disabled</h3>

<p>已禁用<br>
注意直接修改该状态控件不负责重绘</p>

<p><a id="uiCtrlPlusObject.state.dragging"></a></p>

<h3>uiCtrlPlusObject.state.dragging</h3>

<p>是否按下鼠标且正在拖动</p>

<p><a id="uiCtrlPlusObject.state.focus"></a></p>

<h3>uiCtrlPlusObject.state.focus</h3>

<p>是否已得到焦点<br>
注意直接修改该状态控件不负责重绘</p>

<p><a id="uiCtrlPlusObject.state.hover"></a></p>

<h3>uiCtrlPlusObject.state.hover</h3>

<p>鼠标是否在控件上方<br>
注意直接修改该状态控件不负责重绘</p>

<p><a href="https://www.aardio.com/zh-cn/doc/library-reference/win/ui/ctrl/plus.md">Markdown 格式</a></p>

</body> 
</html>