
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="robots" content="index, follow">
<meta name='description' content='aardio 编程语言文档 - wsock.tcp.client 库模块帮助文档'>
<meta http-equiv='content-language' content='zh-cn'>
<title>aardio 编程语言文档 - wsock.tcp.client 库模块帮助文档</title> 
<link rel="stylesheet" href="../../../css/markdown.css" tppabs="https://www.aardio.com/zh-cn/doc/css/markdown.css">
<script src="../../../js/prism.js" tppabs="https://www.aardio.com/zh-cn/doc/js/prism.js"></script>
<link rel="stylesheet" href="../../../../../../lib.baomitu.com/font-awesome/6.6.0/css/fontawesome.min.css" tppabs="https://lib.baomitu.com/font-awesome/6.6.0/css/fontawesome.min.css">
<link rel="stylesheet" href="../../../../../../lib.baomitu.com/font-awesome/6.6.0/css/solid.min.css" tppabs="https://lib.baomitu.com/font-awesome/6.6.0/css/solid.min.css">
</head>
<body class="markdown-body"><a id="back-to-home" href="../../../index.htm" tppabs="https://www.aardio.com/zh-cn/doc/" title="aardio 编程语言文档首页"><i class="fas fa-home" id="home-icon"></i><i class="fas fa-robot" id="ai-icon" style="display: none;"></i><span id="aardio-document-home">aardio 文档</span></a>
<h1>wsock.tcp.client 库模块帮助文档</h1>

<p><a id="wsock.tcp.client"></a></p>

<h2>wsock.tcp.client 成员列表</h2>

<p>TCP客户端支持库</p>

<p><a id="wsock.tcp.client.getLocalIp"></a></p>

<h3>wsock.tcp.client.getLocalIp</h3>

<p>获取上网卡 IP</p>

<p><a id="wsock.tcp.client.getLocalIp"></a></p>

<h3>wsock.tcp.client.getLocalIp(主机,端口,超时秒数)</h3>

<p>获取上网卡 IP，所有参数可省略，<br>
如果指定目标主机与端口，则优先返回访问目标主机的网卡 IP，<br>
主机可指定域名或 IP，建议指定稳定的主机，<br>
端口省略则默认为 80，省略超时参数则默认为 0.3 秒</p>

<p><a id="wsock.tcp.client.test"></a></p>

<h3>wsock.tcp.client.test</h3>

<p>检测目标主机是否可建立 TCP 连接<br>
如果已连接网络则返回建立链接的网卡 IP，否则返回 null</p>

<p><a id="wsock.tcp.client.test"></a></p>

<h3>wsock.tcp.client.test(主机,端口,超时秒数)</h3>

<p>检测目标主机是否可建立 TCP 连接，所有参数可省略。<br>
主机可指定域名或 IP，也可以指定包含多个主机的数组，<br>
端口省略则默认为 80，省略超时参数则默认为 0.3 秒  </p>

<p>如果可以连接任一指定的目标主机则返回建立连接的网卡 IP，<br>
否则返回 null</p>

<p><a id="tcpclientObject"></a></p>

<h2>tcpclientObject 成员列表</h2>

<p><a id="tcpclientObject._onClosed"></a></p>

<h3>tcpclientObject._onClosed</h3>

<pre><code class="aardio language-aardio">tcpclientObject._onClosed = function(){
    /*套接字关闭以前触发  
此回调函数是标准库保留接口  
用户不应使用此回调*/
}
</code></pre>

<p><a id="tcpclientObject.asyncSelect"></a></p>

<h3>tcpclientObject.asyncSelect(event,userMsgId,hwnd)</h3>

<p>检测到由event参数指明的网络事件后,<br>
参数@1使用_FD_前缀的常量指定,可使用位或操作符指定多个选项<br>
事件到达向hwnd指定句柄的窗口发送userMsgId消息,<br>
第二次调用此函数可省略句柄以及消息ID  </p>

<p>失败返回null,以及错误信息,<br>
成功返回true,以及上次调用此函数指定的event参数</p>

<p><a id="tcpclientObject.bind"></a></p>

<h3>tcpclientObject.bind</h3>

<p>绑定 IP 端口。</p>

<p><a id="tcpclientObject.bind"></a></p>

<h3>tcpclientObject.bind(IP,端口)</h3>

<p>绑定 IP 端口。<br>
如果不指定 IP 则默认绑定 0.0.0.0。  </p>

<p>成功返回 true，<br>
失败返回 null,错误信息,错误代码。  </p>

<p>同一套接字重复绑定会返回 10022（_WSAEINVAL） 错误。<br>
重新绑定应当重新创建套接字。<br>
这就好比一张车票只能上一次车。<br>
不能在已经上车以后再要求车站修改车票上的上车地。</p>

<p><a id="tcpclientObject.bufferSize"></a></p>

<h3>tcpclientObject.bufferSize</h3>

<p>读写缓冲区大小，默认为 1MB<br>
缓冲区如果设置的太小，会导致过于频繁的调用读写函数</p>

<p><a id="tcpclientObject.close"></a></p>

<h3>tcpclientObject.close()</h3>

<p>关闭并释放 TCP 客户端。<br>
如果关闭了套接字此函数返回 true<br>
如果套接字已经关闭，此函数返回 null。<br>
如果未显式调用此函数，<br>
在对象析构时,将会自动调用。  </p>

<p>已关闭的套接字不能再使用，需要重连接请重新创建套接字。<br>
就好比用过的车票不能重复用，什么地方都有规则和限制。</p>

<p><a id="tcpclientObject.connect"></a></p>

<h3>tcpclientObject.connect</h3>

<p>创建连接。  </p>

<p>已关闭的套接字不能再使用，需要重连接请重新创建套接字。<br>
就好比用过的车票不能重复用，什么地方都有规则和限制。</p>

<p><a id="tcpclientObject.connect"></a></p>

<h3>tcpclientObject.connect(IP或域名,端口号)</h3>

<p>创建连接，成功返回 true。<br>
也可以在参数 @1 中用一个字符串同时指定 IP 和端口号,IP 与端口号使用冒号分隔。<br>
失败返回 null ，错误信息<br>
异步套接字始终返回 null ，在 onOpen ,onError 回调事件中判断是否连接成功</p>

<p><a id="tcpclientObject.connectTimeout"></a></p>

<h3>tcpclientObject.connectTimeout</h3>

<p>创建连接，可指定超时。  </p>

<p>已关闭的套接字不能再使用，需要重连接请重新创建套接字。<br>
就好比用过的车票不能重复用，什么地方都有规则和限制。</p>

<p><a id="tcpclientObject.connectTimeout"></a></p>

<h3>tcpclientObject.connectTimeout(IP或域名,端口号,超时秒数)</h3>

<p>创建连接，成功返回 true。<br>
也可以在参数 @1 中用一个字符串同时指定 IP 和端口号,IP 与端口号使用冒号分隔。  </p>

<p>注意：超时是以秒为单位，不是毫秒！！<br>
省略超时参数则默认值为 0.5 秒。</p>

<p><a id="tcpclientObject.eachRead"></a></p>

<h3>tcpclientObject.eachRead</h3>

<pre><code class="aardio language-aardio">for(str,readSize,remainSize in tcpclientObject.eachRead() ){   
    /*可选指在eachRead参数中指定最大长度,    
str是本次读取的字符串,readSize是读取的长度,    
remainSize是剩余还没有读取的字节,      
如果限定了最大长度,remainSize为0时才表示读完所有数据,     
此函数不支持unRead送回的数据,也不适合于异步套接字*/  
}
</code></pre>

<p><a id="tcpclientObject.eachReadBuffer"></a></p>

<h3>tcpclientObject.eachReadBuffer</h3>

<pre><code class="aardio language-aardio">for(readSize,remainSize in tcpclientObject.eachReadBuffer() ){   
    /*可选指在eachReadBuffer参数中指定最大长度,  
readSize是读取的长度,buffer的实际长度可能大于readSize,     
remainSize是剩余还没有读取的字节,      
如果限定了最大长度,remainSize为0时才表示读完所有数据      
此函数不支持unRead送回的数据,也不适合于异步套接字*/  
}
</code></pre>

<p><a id="tcpclientObject.flush"></a></p>

<h3>tcpclientObject.flush()</h3>

<p>兼容aardio标准流接口</p>

<p><a id="tcpclientObject.getLocalIp"></a></p>

<h3>tcpclientObject.getLocalIp()</h3>

<p>返回连接的本地IP,端口号</p>

<p><a id="tcpclientObject.getRemoteIp"></a></p>

<h3>tcpclientObject.getRemoteIp()</h3>

<p>返回连接的远程IP,端口号</p>

<p><a id="tcpclientObject.getSocketError"></a></p>

<h3>tcpclientObject.getSocketError()</h3>

<p>获取并同时清除套接字错误代码</p>

<p><a id="tcpclientObject.getopt"></a></p>

<h3>tcpclientObject.getopt(_SO)</h3>

<p>获取选项<br>
参数@1使用_SO_前缀的常量指定选项,参数@2使用结构体指定值<br>
如果不指定参数@2,则获取一个32位整型数值,<br>
可选用参数@3指定设置层次，默认为SOL_SOCKET<br>
成功返回读取的结构体</p>

<p><a id="tcpclientObject.hSocket"></a></p>

<h3>tcpclientObject.hSocket</h3>

<p>套接字句柄。<br>
关闭对象后为空值。<br>
此值应由对象自动维护，调用者不应修改此属性</p>

<p><a id="tcpclientObject.isClosed"></a></p>

<h3>tcpclientObject.isClosed()</h3>

<p>套接字是否已关闭</p>

<p><a id="tcpclientObject.isConnected"></a></p>

<h3>tcpclientObject.isConnected()</h3>

<p>套接字是否已连接</p>

<p><a id="tcpclientObject.lastSelectEvent"></a></p>

<h3>tcpclientObject.lastSelectEvent</h3>

<p>最后一次调用asyncSelect应用的事件<br>
不可手动修改此属性，应由对象自动维护</p>

<p><a id="tcpclientObject.lastSelectHwnd"></a></p>

<h3>tcpclientObject.lastSelectHwnd</h3>

<p>最后一次调用asyncSelect应用的窗口句柄<br>
不可手动修改此属性，应由对象自动维护</p>

<p><a id="tcpclientObject.lastSelectMessageId"></a></p>

<h3>tcpclientObject.lastSelectMessageId</h3>

<p>最后一次调用asyncSelect应用的消息ID<br>
不可手动修改此属性，应由对象自动维护</p>

<p><a id="tcpclientObject.onClosed"></a></p>

<h3>tcpclientObject.onClosed</h3>

<pre><code class="aardio language-aardio">tcpclientObject.onClosed = function(){
    /*套接字关闭以前触发*/
}
</code></pre>

<p><a id="tcpclientObject.peek"></a></p>

<h3>tcpclientObject.peek(长度)</h3>

<p>读取但并不移除缓冲区的数据,返回字符串<br>
不指定参数则使用bufferSize指定的大小分配buffer并尝试读取</p>

<p><a id="tcpclientObject.read"></a></p>

<h3>tcpclientObject.read</h3>

<p>读取数据<br>
此函数等待数据到达,<br>
但如果参数未省略且不是-1,则不保证读取达到定的长度<br>
如果要等待直到指定长度应改用 readEx 函数</p>

<p><a id="tcpclientObject.read"></a></p>

<h3>tcpclientObject.read(读取长度)</h3>

<p>读取数据<br>
参数可以指定长度,也可以使用接收数据的结构体作为参数<br>
参数为-1表示读到尾部,无参数表示读取一行,<br>
使用CRLF回车换行符分行  </p>

<p>此函数等待数据到达,<br>
但如果参数未省略且不是-1,则不保证读取达到定的长度</p>

<p><a id="tcpclientObject.readAll"></a></p>

<h3>tcpclientObject.readAll()</h3>

<p>接收全部数据<br>
该函数读取直至连接关闭,应慎用该函数防止服务器保持连接无法返回</p>

<p><a id="tcpclientObject.readAlloc"></a></p>

<h3>tcpclientObject.readAlloc</h3>

<p>循环读取数据到动态指针内,<br>
动态指针的使用风险较大,如果不是非常熟悉其规则,<br>
建议不要使用此函数  </p>

<p>对象所有read前缀的成员函数底层基本都是调用这个函数<br>
此函数读取的数据支持调用unRead或unReadAlloc,<br>
撤消并退回到读缓冲区</p>

<p><a id="tcpclientObject.readAlloc"></a></p>

<h3>tcpclientObject.readAlloc()</h3>

<p>循环读取数据，直到读取结束,</p>

<p><a id="tcpclientObject.readAlloc"></a></p>

<h3>tcpclientObject.readAlloc(动态指针)</h3>

<p>循环读取数据并存入参数指定的动态指针,<br>
返回新的指针地址和内存长度,<br>
此函数可能更新指针地址或分配的内存大小，<br>
必须使用返回的新指针覆盖原来保存该动态指针的变量值</p>

<p><a id="tcpclientObject.readAlloc"></a></p>

<h3>tcpclientObject.readAlloc(读取长度)</h3>

<p>循环读取数据，直到达到参数中限定的最大长度<br>
读取长度不可指定负数,负数仅用于界面线程异步套接字<br>
无数据返回null，  </p>

<p>如果读取到数据则返回2个值：动态指针,内存长度<br>
调用者必须负责调用 raw.realloc(0,动态指针)<br>
释放返回值1返回的指针  </p>

<p>此函数直接操作内存，效率更好<br>
但一定要记住释放返回的内存指针</p>

<p><a id="tcpclientObject.readAllocEx"></a></p>

<h3>tcpclientObject.readAllocEx(读取长度)</h3>

<p>读取数据达到指定长度,参数不可省略<br>
成功返回动态指针,数据长度,<br>
动态指针必须用 raw.realloc 函数释放,<br>
非必要请不要直接使用此函数,应改用 readEx 函数<br>
此函数不可用于异步套接字</p>

<p><a id="tcpclientObject.readBuffer"></a></p>

<h3>tcpclientObject.readBuffer(缓冲区,读取长度)</h3>

<p>读取数据,返回 buffer 对象,<br>
省略所有参数则读取所有数据，<br>
参数@1可选指定一个使用 buffer 对象，<br>
省略读取长度时取缓冲区长度，  </p>

<p>如果参数@1指定了缓冲区,成功返回读取长度,<br>
否则成功返回缓冲区，<br>
失败返回null</p>

<p><a id="tcpclientObject.readDelayInterval"></a></p>

<h3>tcpclientObject.readDelayInterval</h3>

<p>数据尚未到达时的等待时间<br>
此属性仅适用于界面线程异步套接字<br>
仅在读取长度为负值是有效</p>

<p><a id="tcpclientObject.readEx"></a></p>

<h3>tcpclientObject.readEx(读取长度)</h3>

<p>读取数据达到指定长度,参数不可省略<br>
成功返回字符串,如果套接字关闭,则返回已读取的数据<br>
此函数不可用于异步套接字</p>

<p><a id="tcpclientObject.readOobByte"></a></p>

<h3>tcpclientObject.readOobByte()</h3>

<p>读取一个字节的紧急数据,返回字节码</p>

<p><a id="tcpclientObject.readTo"></a></p>

<h3>tcpclientObject.readTo</h3>

<p>读取直到以指定的字符串结束<br>
如果只是读取部分数据并没有获取到结束标记，第二个返回值为true<br>
否则只会返回一个值,成功返回读取字符串,<br>
失败返回null</p>

<p><a id="tcpclientObject.readTo"></a></p>

<h3>tcpclientObject.readTo(&#39;结束串&#39;)</h3>

<p>读取直到以指定的字符串结束,返回值不包含结束串,<br>
该函数每次仅读取一个字节,效率较低</p>

<p><a id="tcpclientObject.readTo"></a></p>

<h3>tcpclientObject.readTo(&#39;结束串&#39;,true)</h3>

<p>读取直到以指定的字符串结束,返回值不包含结束串,<br>
如果没有读取到数据，则循环等待，等待时继续处理界面消息<br>
此用法仅适用于界面线程异步套接字<br>
该函数每次仅读取一个字节,效率较低</p>

<p><a id="tcpclientObject.readyState"></a></p>

<h3>tcpclientObject.readyState</h3>

<p>套接字连接状态,<br>
0 为等待连接,1 为已连接,2 为正在关闭,3 为已关闭</p>

<p><a id="tcpclientObject.recv"></a></p>

<h3>tcpclientObject.recv(最大接收长度)</h3>

<p>单次接收数据包<br>
如果参数不指定长度，则使用bufferSize指定的长度<br>
成功返回字符串,<br>
失败返回null,错误代码</p>

<p><a id="tcpclientObject.recvBuffer"></a></p>

<h3>tcpclientObject.recvBuffer(缓冲区,读取长度)</h3>

<p>单次接收数据包<br>
参数@1指定 buffer 对象,<br>
参数@2可省略,默认为缓冲区长度,<br>
成功返回接收的长度,<br>
失败返回null,错误代码</p>

<p><a id="tcpclientObject.reuseAddress"></a></p>

<h3>tcpclientObject.reuseAddress(true)</h3>

<p>是否允许端口重用</p>

<p><a id="tcpclientObject.send"></a></p>

<h3>tcpclientObject.send(数据,长度)</h3>

<p>单次发送数据包<br>
成功返回发送的数据长度,<br>
失败返回null,错误代码</p>

<p><a id="tcpclientObject.sendbuffer10035"></a></p>

<h3>tcpclientObject.sendbuffer10035</h3>

<p>异步套接字发送缓冲区,用户不应修改此对象</p>

<p><a id="tcpclientObject.setTimeouts"></a></p>

<h3>tcpclientObject.setTimeouts(发送超时,接收超时)</h3>

<p>设置超时,以亳秒为单位(1秒为1000毫秒)</p>

<p><a id="tcpclientObject.setopt"></a></p>

<h3>tcpclientObject.setopt(_SO)</h3>

<p>设置选项<br>
参数@1使用_SO_前缀的常量指定选项,参数@2使用结构体、数值、布尔值都可以<br>
可选用参数@3指定设置层次，默认为SOL_SOCKET<br>
成功返回true</p>

<p><a id="tcpclientObject.shutdown"></a></p>

<h3>tcpclientObject.shutdown()</h3>

<p>断开连接。<br>
参数中指定 0 为仅停止收数据，指定 1 为停止发数据。<br>
默认值为 2 表示停止收发送数据。<br>
此函数并不销毁套接字句柄。  </p>

<p>已断开连接的套接字不能再使用，需要重连接请重新创建套接字。<br>
就好比用过的车票不能重复用，什么地方都有规则和限制。</p>

<p><a id="tcpclientObject.unRead"></a></p>

<h3>tcpclientObject.unRead()</h3>

<p>把read,readTo,readBuffer等函数读出的数据退回缓存，<br>
注意退回数据的顺序是“后出先进”，<br>
最后读出的应当最先退回</p>

<p><a id="tcpclientObject.unReadAlloc"></a></p>

<h3>tcpclientObject.unReadAlloc()</h3>

<p>把readAlloc读取的动态指针退回缓存,  </p>

<p>注意退回数据的顺序是“后出先进”，<br>
最后读出的应当最先退回</p>

<p><a id="tcpclientObject.write"></a></p>

<h3>tcpclientObject.write(...)</h3>

<p>发送数据,<br>
支持一个或多个参数，参数支持字符串、buffer (buffer)、数值、结构体<br>
成功返回true</p>

<p><a id="tcpclientObject.writeBuffer"></a></p>

<h3>tcpclientObject.writeBuffer(缓冲区,长度)</h3>

<p>发送数据,<br>
参数@1应使用 buffer 对象,<br>
可选使用参数2指定长度<br>
成功返回true</p>

<p><a id="wsock.tcp"></a></p>

<h2>wsock.tcp 成员列表</h2>

<p><a id="wsock.tcp.client"></a></p>

<h3>wsock.tcp.client()</h3>

<p><a href="client.html#tcpclientObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/wsock/tcp/client.html#tcpclientObject">返回对象:tcpclientObject</a></p>

<p><a id="wsock.tcp.client"></a></p>

<h3>wsock.tcp.client(套接字句柄)</h3>

<p>绑定套接字句柄并返回TCP客户端对象</p>

<p><a id="wsock.tcp.client"></a></p>

<h3>wsock.tcp.client(缓冲区大小,套接字句柄)</h3>

<p>创建 TCP 客户端,<br>
套接字为空则创建套接字,否则绑定套接字句柄,<br>
缓冲区大小为可选参数,默认为1KB</p>

<p><a href="javascript:if(confirm('https://www.aardio.com/zh-cn/doc/library-reference/wsock/tcp/client.md  \n\nļ޷ Teleport Ultra , Ϊ Ŀļ͹淶ڡ  \n\nڷϴ?'))window.location='https://www.aardio.com/zh-cn/doc/library-reference/wsock/tcp/client.md'" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/wsock/tcp/client.md">Markdown 格式</a></p>

</body> 
</html>