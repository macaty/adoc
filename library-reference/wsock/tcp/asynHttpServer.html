
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="robots" content="index, follow">
<meta name='description' content='aardio 编程语言文档 - wsock.tcp.asynHttpServer 库模块帮助文档'>
<meta http-equiv='content-language' content='zh-cn'>
<title>aardio 编程语言文档 - wsock.tcp.asynHttpServer 库模块帮助文档</title> 
<link rel="stylesheet" href="../../../css/markdown.css" tppabs="https://www.aardio.com/zh-cn/doc/css/markdown.css">
<script src="../../../js/prism.js" tppabs="https://www.aardio.com/zh-cn/doc/js/prism.js"></script>
<link rel="stylesheet" href="../../../../../../lib.baomitu.com/font-awesome/6.6.0/css/fontawesome.min.css" tppabs="https://lib.baomitu.com/font-awesome/6.6.0/css/fontawesome.min.css">
<link rel="stylesheet" href="../../../../../../lib.baomitu.com/font-awesome/6.6.0/css/solid.min.css" tppabs="https://lib.baomitu.com/font-awesome/6.6.0/css/solid.min.css">
</head>
<body class="markdown-body"><a id="back-to-home" href="../../../index.htm" tppabs="https://www.aardio.com/zh-cn/doc/" title="aardio 编程语言文档首页"><i class="fas fa-home" id="home-icon"></i><i class="fas fa-robot" id="ai-icon" style="display: none;"></i><span id="aardio-document-home">aardio 文档</span></a>
<h1>wsock.tcp.asynHttpServer 库模块帮助文档</h1>

<p><a id="asynHttpServerObject"></a></p>

<h2>asynHttpServerObject 成员列表</h2>

<p><a id="asynHttpServerObject._beforeHttpServerStop"></a></p>

<h3>asynHttpServerObject._beforeHttpServerStop</h3>

<pre><code class="aardio language-aardio">asynHttpServerObject._beforeHttpServerStop = function(){
    /*服务端关闭以前触发  
此回调函数是标准库保留接口  
用户不应使用此回调*/
}
</code></pre>

<p><a id="asynHttpServerObject._onClientClosed"></a></p>

<h3>asynHttpServerObject._onClientClosed</h3>

<pre><code class="aardio language-aardio">asynHttpServerObject._onClientClosed = function(hSocket){
    /*客户端连接已经关闭时触发  
此函数在连接断开后一定会被触发  
此回调函数是标准库保留接口  
用户不应使用此回调*/
}
</code></pre>

<p><a id="asynHttpServerObject.acceptCount"></a></p>

<h3>asynHttpServerObject.acceptCount</h3>

<p>当前连接数,不可改动该值</p>

<p><a id="asynHttpServerObject.beforeStop"></a></p>

<h3>asynHttpServerObject.beforeStop</h3>

<pre><code class="aardio language-aardio">asynHttpServerObject.beforeStop = function(){
    /*服务端关闭以前触发*/
}
</code></pre>

<p><a id="asynHttpServerObject.bind"></a></p>

<h3>asynHttpServerObject.bind(IP,端口)</h3>

<p>绑定 IP 与端口。<br>
应当由 start 函数自动调用此函数。</p>

<p><a id="asynHttpServerObject.clearKeepAliveTimeout"></a></p>

<h3>asynHttpServerObject.clearKeepAliveTimeout()</h3>

<p>关闭所有超出keepAliveTimeout限制的超时连接<br>
在连接超出最大连接数时,此函数会被自动调用</p>

<p><a id="asynHttpServerObject.client"></a></p>

<h3>asynHttpServerObject.client()</h3>

<p><a href="asynClient.html#tcpaclientObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/wsock/tcp/asynClient.html#tcpaclientObject">返回对象:tcpaclientObject</a></p>

<p><a id="asynHttpServerObject.client"></a></p>

<h3>asynHttpServerObject.client(hSocket)</h3>

<p>用于获取客户端套接字对应的客户端对象</p>

<p><a id="asynHttpServerObject.clientBufferSize"></a></p>

<h3>asynHttpServerObject.clientBufferSize</h3>

<p>客户端套接字读写缓冲区大小，默认为1MB<br>
缓冲区如果设置的太小，会导致过于频繁的调用读写函数</p>

<p><a id="asynHttpServerObject.customErrors"></a></p>

<h3>asynHttpServerObject.customErrors</h3>

<pre><code class="aardio language-aardio">asynHttpServerObject.customErrors = {  
    [404] = function(response){  
        response.status = &quot;404 Not Found&quot;;  
        response.write(&quot;404 Not Found&quot;); /*自定义错误页，  
也可以直接指定错误页路径*/  
    }   
}
</code></pre>

<p><a id="asynHttpServerObject.defalutDocument"></a></p>

<h3>asynHttpServerObject.defalutDocument</h3>

<p>默认文档，默认为&quot;main.aardio&quot;,  </p>

<p>如果访问硬盘上存在的目录,request.path 尾部不加斜杠会自动跳转到以斜杆结束的路径  </p>

<p>如果访问嵌入资源目录,只有 request.path 以斜杆才会访问默认文档,<br>
对于访问嵌入资源文件,建议指定完整的文件路径,<br>
默认文档主要是用于硬盘上的网站</p>

<p><a id="asynHttpServerObject.defaultUrl"></a></p>

<h3>asynHttpServerObject.defaultUrl</h3>

<p>访问此服务器的默认网址</p>

<p><a id="asynHttpServerObject.documentBase"></a></p>

<h3>asynHttpServerObject.documentBase</h3>

<p>网站根目录,<br>
不会修改应用程序根目录,支持硬盘目录与资源目录,<br>
这个属性应当设置为应用程序根目录下的相对路径,<br>
例如 &quot;/res/web/&quot;  </p>

<p>注意： request.path 前面包含 documentBase 目录。<br>
而 request.pathInfo 忽略 documentBase 目录</p>

<p><a id="asynHttpServerObject.documentRoot"></a></p>

<h3>asynHttpServerObject.documentRoot</h3>

<p>网站应用程序根目录,默认为&quot;/&quot;,<br>
只能设置为硬盘上实际存在的目录,<br>
改变此目录,会同时改变<br>
服务端代码中的应用程序根目录以及用户库目录,<br>
如果只是相将所有请求路径转向某个目录,应当改用 documentBase 属性<br>
如果网站在嵌入资源目录中,应当改用 documentBase 属性</p>

<p><a id="asynHttpServerObject.getLocalIp"></a></p>

<h3>asynHttpServerObject.getLocalIp()</h3>

<p>返回当前绑定的IP,端口号</p>

<p><a id="asynHttpServerObject.getRemoteIp"></a></p>

<h3>asynHttpServerObject.getRemoteIp(hSocket)</h3>

<p>返回客户端IP地址,端口</p>

<p><a id="asynHttpServerObject.getUrl"></a></p>

<h3>asynHttpServerObject.getUrl</h3>

<p>返回 HTTP 服务端访问网址<br>
如果服务器启动失败不返回任何值</p>

<p><a id="asynHttpServerObject.getUrl"></a></p>

<h3>asynHttpServerObject.getUrl()</h3>

<p>返回首页网址</p>

<p><a id="asynHttpServerObject.getUrl"></a></p>

<h3>asynHttpServerObject.getUrl(path,localIp)</h3>

<p>返回 @path 指定路径的网址，路径开始可省略斜杠。<br>
注意参数第一个字符不需要指定斜杠<br>
可选用 @localIp 指定 IP &quot;0.0.0.0&quot; 是否替换为上网卡 IP（否则 localhost ）</p>

<p><a id="asynHttpServerObject.getUrl"></a></p>

<h3>asynHttpServerObject.getUrl(path,param,localIp)</h3>

<p>返回 @path 指定路径的网址，路径开始可省略斜杠。<br>
@param 指定 URL 参数表（table 对象）。<br>
可选用 @localIp 指定 IP &quot;0.0.0.0&quot; 是否替换为上网卡 IP（否则 localhost ）</p>

<p><a id="asynHttpServerObject.isClosed"></a></p>

<h3>asynHttpServerObject.isClosed(hSocket)</h3>

<p>连接是否已关闭</p>

<p><a id="asynHttpServerObject.isConnected"></a></p>

<h3>asynHttpServerObject.isConnected(hSocket)</h3>

<p>是否已连接并准备就绪</p>

<p><a id="asynHttpServerObject.keepAliveTimeout"></a></p>

<h3>asynHttpServerObject.keepAliveTimeout</h3>

<p>最大保持连接时间,以秒为单位,<br>
负数表示不限时间</p>

<p><a id="asynHttpServerObject.listen"></a></p>

<h3>asynHttpServerObject.listen(请求队列大小)</h3>

<p>监听构造函数绑定的 IP 端口，成功返回 true 。<br>
已自动调用此函数。</p>

<p><a id="asynHttpServerObject.maxConnection"></a></p>

<h3>asynHttpServerObject.maxConnection</h3>

<p>最大连接数</p>

<p><a id="asynHttpServerObject.onClientClosed"></a></p>

<h3>asynHttpServerObject.onClientClosed</h3>

<pre><code class="aardio language-aardio">asynHttpServerObject.onClientClosed = function(hSocket){
    /*客户端连接已经关闭时触发  
此函数在连接断开后一定会被触发*/
}
</code></pre>

<p><a id="asynHttpServerObject.onClose"></a></p>

<h3>asynHttpServerObject.onClose</h3>

<pre><code class="aardio language-aardio">asynHttpServerObject.onClose = function(hSocket,err){
    var client = asynHttpServerObject.client(hSocket);

    /*已断开连接,  
如果缓冲区中仍然有数据,  
这个事件可能在其他事件前面触发  
主动调用close函数立即关闭连接,此事件不会被触发,  
但onClientClosed事件总会在关闭连接后触发*/ 
}
</code></pre>

<p><a id="asynHttpServerObject.onOpen"></a></p>

<h3>asynHttpServerObject.onOpen</h3>

<pre><code class="aardio language-aardio">asynHttpServerObject.onOpen = function(hSocket,err){
    var client = asynHttpServerObject.client(hSocket);

    /*已连接  
在这里可以开始发送数据*/ 
}
</code></pre>

<p><a id="asynHttpServerObject.onOutOfBandData"></a></p>

<h3>asynHttpServerObject.onOutOfBandData</h3>

<pre><code class="aardio language-aardio">asynHttpServerObject.onOutOfBandData = function(hSocket,err){
    var client = asynHttpServerObject.client(hSocket);

    /*收到紧急数据  
即send函数最后一个flag参数设为_MSG_OOB时发送的1字节带外数据*/      
}
</code></pre>

<p><a id="asynHttpServerObject.onRead"></a></p>

<h3>asynHttpServerObject.onRead</h3>

<pre><code class="aardio language-aardio">asynHttpServerObject.onRead = function(hSocket,err){
    var client = asynHttpServerObject.client(hSocket);

    /*收到数据  
可阻塞读取数据  
定义了此事件就不应同时定义onReceive事件*/    
}
</code></pre>

<p><a id="asynHttpServerObject.onReceive"></a></p>

<h3>asynHttpServerObject.onReceive</h3>

<pre><code class="aardio language-aardio">asynHttpServerObject.onReceive = function(hSocket,err){
    var client = asynHttpServerObject.client(hSocket);

    /*收到数据  
仅读取已到达的数据  
定义了此事件就不应同时定义onRead事件*/   
}
</code></pre>

<p><a id="asynHttpServerObject.onSend"></a></p>

<h3>asynHttpServerObject.onSend</h3>

<pre><code class="aardio language-aardio">asynHttpServerObject.onSend = function(hSocket,err){
    var client = asynHttpServerObject.client(hSocket);

    /*发送数据*/
}
</code></pre>

<p><a id="asynHttpServerObject.onStop"></a></p>

<h3>asynHttpServerObject.onStop</h3>

<pre><code class="aardio language-aardio">asynHttpServerObject.onStop = function(err){


    /*已停止服务端  
主动调用stop函数停止服务端时不会触发此事件*/ 
}
</code></pre>

<p><a id="asynHttpServerObject.onUpgradeProtocol"></a></p>

<h3>asynHttpServerObject.onUpgradeProtocol</h3>

<pre><code class="aardio language-aardio">asynHttpServerObject.onUpgradeProtocol = function(client,request,response){
    /*处理客户端升级协议请求,  
可在此回调中切换到WebSocket协议*/
}
</code></pre>

<p><a id="asynHttpServerObject.run"></a></p>

<h3>asynHttpServerObject.run(httpProc)</h3>

<pre><code class="aardio language-aardio">asynHttpServerObject.run(   
    function(response,request,session){   
         response.loadcode(request.path);  
    }/*启动HTTP服务并在此回调函数中处理请求，  
不传入参数则默认调用response.loadcode 。  
也可以传入一个或多个表参数,键为页面相对路径,值为响应数据或回调函数,  
键指定的路径为 aardio 后缀时，启用模板语法解析并返回 HTML 代码*/  
);
</code></pre>

<p><a id="asynHttpServerObject.serverAddress"></a></p>

<h3>asynHttpServerObject.serverAddress</h3>

<p>服务端监听地址  </p>

<p><a href="#sockaddrInObject">返回对象:sockaddrInObject</a></p>

<p><a id="asynHttpServerObject.shutdown"></a></p>

<h3>asynHttpServerObject.shutdown()</h3>

<p>断开 HTTP 服务端</p>

<p><a id="asynHttpServerObject.spaUrl"></a></p>

<h3>asynHttpServerObject.spaUrl</h3>

<p>返回 SPA 单页应用首页网址<br>
如未启动服务端则自动启动且监听IP设为 &quot;127.0.0.1&quot;</p>

<p><a id="asynHttpServerObject.spaUrl"></a></p>

<h3>asynHttpServerObject.spaUrl(indexHtmlPath,documentBase)</h3>

<p>参数指定 SPA 单页应用首页路径，<br>
404错误页也会自动设置到该路径，<br>
返回首页网址  </p>

<p>可选用参数 @documentBase 指定根目录以避免网页不支持非根目录路径</p>

<p><a id="asynHttpServerObject.start"></a></p>

<h3>asynHttpServerObject.start(IP,端口,请求队列大小)</h3>

<p>启动单线程异步TCP服务端,成功返回true,失败返回null,  </p>

<p>如果不写IP，则默认设为&quot;0.0.0.0&quot;也即监听本机所有IP,访问此服务端也不限制IP<br>
限制仅本机可以访问建议写127.0.0.1  </p>

<p>端口为0或省略则自动查找1025以后的空闲端口<br>
注意0-1023为系统通用服务保留端口,<br>
1024-49151为用户服务端口,其中大约%9已由IANA注册分配<br>
49152-65535为私有或临时端口</p>

<p><a id="asynHttpServerObject.stop"></a></p>

<h3>asynHttpServerObject.stop()</h3>

<p>关闭 HTTP 服务端</p>

<p><a id="asynHttpServerObject.clients"></a></p>

<h2>asynHttpServerObject.clients 成员列表</h2>

<p>这是一个包含所有客户端套接字的表对象<br>
其中键为套接字句柄,值为 wsock.tcp.asynClient对象</p>

<p><a id="asynHttpServerObject.clients.?"></a></p>

<h3>asynHttpServerObject.clients.?</h3>

<p><a href="asynClient.html#tcpaclientObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/wsock/tcp/asynClient.html#tcpaclientObject">返回对象:tcpaclientObject</a></p>

<p><a id="wsock.tcp"></a></p>

<h2>wsock.tcp 成员列表</h2>

<p><a id="wsock.tcp.asynHttpServer"></a></p>

<h3>wsock.tcp.asynHttpServer</h3>

<p>单线程异步 HTTP 服务端<br>
浏览器组件发起异步 HTTP 请求支持 asynHttpServer。<br>
请不要用 inet.http 等阻塞请求同一线程创建的 asynHttpServer,<br>
 这会导致 asynHttpServer 没有机会响应请求而导致死锁，<br>
一般没必要这样自己 HTTP 请求自己，改成普通函数调用即可，<br>
如果确有这样的需求，可以创建线程调用 inet.http 发起请求，<br>
或改用基于多线程的 wsock.tcp.simpleHttpServer 创建服务端</p>

<p><a id="wsock.tcp.asynHttpServer"></a></p>

<h3>wsock.tcp.asynHttpServer()</h3>

<p>创建单线程异步 HTTP 服务端  </p>

<p><a href="asynHttpServer.html#asynHttpServerObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/wsock/tcp/asynHttpServer.html#asynHttpServerObject">返回对象:asynHttpServerObject</a></p>

<p><a href="https://www.aardio.com/zh-cn/doc/library-reference/wsock/tcp/asynHttpServer.md">Markdown 格式</a></p>

</body> 
</html>