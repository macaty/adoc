
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="robots" content="index, follow">
<meta name='description' content='aardio 编程语言文档 - dotNet.appDomain 库模块帮助文档'>
<meta http-equiv='content-language' content='zh-cn'>
<title>aardio 编程语言文档 - dotNet.appDomain 库模块帮助文档</title> 
<link rel="stylesheet" href="../../css/markdown.css" tppabs="https://www.aardio.com/zh-cn/doc/css/markdown.css">
<script src="../../js/prism.js" tppabs="https://www.aardio.com/zh-cn/doc/js/prism.js"></script>
<link rel="stylesheet" href="../../../../../lib.baomitu.com/font-awesome/6.6.0/css/fontawesome.min.css" tppabs="https://lib.baomitu.com/font-awesome/6.6.0/css/fontawesome.min.css">
<link rel="stylesheet" href="../../../../../lib.baomitu.com/font-awesome/6.6.0/css/solid.min.css" tppabs="https://lib.baomitu.com/font-awesome/6.6.0/css/solid.min.css">
</head>
<body class="markdown-body"><a id="back-to-home" href="../../index.htm" tppabs="https://www.aardio.com/zh-cn/doc/" title="aardio 编程语言文档首页"><i class="fas fa-home" id="home-icon"></i><i class="fas fa-robot" id="ai-icon" style="display: none;"></i><span id="aardio-document-home">aardio 文档</span></a>
<h1>dotNet.appDomain 库模块帮助文档</h1>

<p><a id="dotNet"></a></p>

<h2>dotNet 成员列表</h2>

<p><a id="dotNet.appDomain"></a></p>

<h3>dotNet.appDomain</h3>

<p>创建应用程序域,<br>
注意应当通过导入 dotNet 库自动导入 dotNet.appDomain</p>

<p><a id="dotNet.appDomain"></a></p>

<h3>dotNet.appDomain()</h3>

<p>不指定参数为当前线程创建唯一的应用程序域实例,<br>
该实例可能被其他代码使用,主动调用 unload 函数会被忽略,<br>
线程结束前会自动释放此实例。  </p>

<p>成功返回应用程序域,失败返回 null,错误信息,<br>
失败一般是因为系统没有安装 .NET 运行时。<br>
除了XP系统，WIN7 以及 WIN7 以上系统已自带 .NET 运行时,<br>
所以不检测返回值也行。  </p>

<p>注意应当通过导入 dotNet 库自动导入 dotNet.appDomain</p>

<p><a href="#dotNetAppDomainObject">返回对象:dotNetAppDomainObject</a></p>

<p><a id="dotNet.appDomain"></a></p>

<h3>dotNet.appDomain(clr,domainName)</h3>

<p>参数 @clr 指定 dotNet.clr 对象，<br>
可选用 @domainName 指定应用程序域名称，<br>
指定参数时应改用 dotNet.clr 对象的 createAppDomain 函数  </p>

<p>无参数调用 dotNet.appDomain 总是返回默认单例应用程序域，<br>
引入 dotNet 库也会自动创建默认应用程序域</p>

<p><a id="NetDictionaryObject"></a></p>

<h2>NetDictionaryObject 成员列表</h2>

<p><a id="NetDictionaryObject.Add"></a></p>

<h3>NetDictionaryObject.Add(key,value)</h3>

<p>添加键值</p>

<p><a id="NetDictionaryObject.Clear"></a></p>

<h3>NetDictionaryObject.Clear()</h3>

<p>清空字典</p>

<p><a id="NetDictionaryObject.ContainsKey"></a></p>

<h3>NetDictionaryObject.ContainsKey(key)</h3>

<p>是否包含参数 @key 指定键的值</p>

<p><a id="NetDictionaryObject.ContainsValue"></a></p>

<h3>NetDictionaryObject.ContainsValue(value)</h3>

<p>是否包含参数 @value 指定值的键</p>

<p><a id="NetDictionaryObject.Count"></a></p>

<h3>NetDictionaryObject.Count</h3>

<p>包含键值对总数</p>

<p><a id="NetDictionaryObject.Remove"></a></p>

<h3>NetDictionaryObject.Remove(key)</h3>

<p>移除参数 @key 指定的键值</p>

<p><a id="dotNetAppDomainObject"></a></p>

<h2>dotNetAppDomainObject 成员列表</h2>

<p><a id="dotNetAppDomainObject.Array"></a></p>

<h3>dotNetAppDomainObject.Array</h3>

<pre><code class="aardio language-aardio">System.Array
</code></pre>

<p><a id="dotNetAppDomainObject.Drawing"></a></p>

<h3>dotNetAppDomainObject.Drawing</h3>

<pre><code class="aardio language-aardio">System.Drawing
</code></pre>

<p><a id="dotNetAppDomainObject.appDomainReal"></a></p>

<h3>dotNetAppDomainObject.appDomainReal</h3>

<p>AppDomain 托管对象</p>

<p><a id="dotNetAppDomainObject.buffer"></a></p>

<h3>dotNetAppDomainObject.buffer(初始值)</h3>

<p>分配可读写的、固定长度的字节数组。<br>
参数可以是一个结构体、字符串、或 buffer,传入{ }返回null,<br>
重新分配内存并复制初始值指定的数据。<br>
返回封包 buffer 的 dotNet.object 对象</p>

<p><a id="dotNetAppDomainObject.buffer"></a></p>

<h3>dotNetAppDomainObject.buffer(长度,初始值)</h3>

<p>分配可读写的、固定长度的字节数组。  </p>

<p>参数一指定需要分配的内存大小,<br>
,内存初始值可以用结构体、指针、buffer、或字符串指定一段内存数据,<br>
也可用一个数值指定所有字节的初始值,不指定默认初始化所有字节为0,  </p>

<p>如果初始值指定为字符串或buffer类型，<br>
填充初始数据以后剩余的字节会全部初始为为0<br>
返回封包 buffer 的 dotNet.object 对象</p>

<p><a id="dotNetAppDomainObject.byte"></a></p>

<h3>dotNetAppDomainObject.byte</h3>

<p>创建 .NET System.SByte 类型数值或数组</p>

<p><a id="dotNetAppDomainObject.byte"></a></p>

<h3>dotNetAppDomainObject.byte(value,byRef)</h3>

<p>创建 .NET System.SByte 类型数值或数组，<br>
用于存储8位整数。  </p>

<p>参数 @value 可以为数值或数组，<br>
参数 @byRef 为 true 则支持 .NET 的输出或引用参数</p>

<p><a id="dotNetAppDomainObject.clr"></a></p>

<h3>dotNetAppDomainObject.clr</h3>

<p>.NET 运行时  </p>

<p><a href="#dotNetClrObject">返回对象:dotNetClrObject</a></p>

<p><a id="dotNetAppDomainObject.createArray"></a></p>

<h3>dotNetAppDomainObject.createArray</h3>

<p>创建 .NET 类型化数组。<br>
.NET 通常要求数组类型完全匹配，可以用这个函数创建类型匹配的数组。  </p>

<p>包含.NET 对象的普通 aardio 数组在传入 .NET 时也会临时转换为类型化数组<br>
默认的普通数值数组传入 .NET 为 double 数组，但支持自适应转换类型。<br>
也可以用 dotNet.double,dotNet.int 等函数创建类型化数值数组。  </p>

<p>注意 .NET 数组对象应当用 Length 属性取数组长度而非用 #号取长度，<br>
.NET 中的简单值类型数组在 aardio 中会转换为 com.SafeArray 数组，<br>
com.SafeArray 数组可以用 &num; 取长度</p>

<p><a id="dotNetAppDomainObject.createArray"></a></p>

<h3>dotNetAppDomainObject.createArray(数组)</h3>

<p>参数 @1 请指定数组。<br>
包含.NET 对象的普通数组返回为 .NET 类型化数组，<br>
传入其他任何类型参数直接返回</p>

<p><a id="dotNetAppDomainObject.createArray"></a></p>

<h3>dotNetAppDomainObject.createArray(类型,长度...)</h3>

<p>参数 @1 请指定 .NET 类型，<br>
类型通常由 dotNet.import 导入，或用 .NET 对象的 GetType 函数获取。<br>
至少指定一个数组长度参数，可指定多个长度参数以创建多维数组</p>

<p><a id="dotNetAppDomainObject.createArrayList"></a></p>

<h3>dotNetAppDomainObject.createArrayList()</h3>

<p><a href="#dotNetCrlArrayListObject">返回对象:dotNetCrlArrayListObject</a></p>

<p><a id="dotNetAppDomainObject.createArrayList"></a></p>

<h3>dotNetAppDomainObject.createArrayList(初始化数组)</h3>

<p>创建 System.Collections.ArrayList 对象<br>
可传递到C#函数中,C#中应声明为 object 类型,然后强制转换为 ArrayList,<br>
可选参数一指定 table 数组用于初始化对象</p>

<p><a id="dotNetAppDomainObject.createCompiler"></a></p>

<h3>dotNetAppDomainObject.createCompiler(&quot;C#&quot;)</h3>

<p>创建C#编译器</p>

<p><a id="dotNetAppDomainObject.createCompiler"></a></p>

<h3>dotNetAppDomainObject.createCompiler(&quot;VB&quot;)</h3>

<p>创建VB编译器</p>

<p><a id="dotNetAppDomainObject.createCompiler"></a></p>

<h3>dotNetAppDomainObject.createCompiler()</h3>

<p><a href="#dotNetCompilerObject">返回对象:dotNetCompilerObject</a></p>

<p><a id="dotNetAppDomainObject.createInstance"></a></p>

<h3>dotNetAppDomainObject.createInstance(程序集,&quot;类名&quot;,其他调用参数)</h3>

<p>参数一可以是程序集对象,名称或路径都可以,<br>
调用类的构造函数,支持传入多个调用参数并返回创建的对象。<br>
失败返回空值,以及错误信息</p>

<p><a id="dotNetAppDomainObject.createNameValueList"></a></p>

<h3>dotNetAppDomainObject.createNameValueList(names,values)</h3>

<p>创建 List<NameValue<K,V>&gt; 列表对象,<br>
参数@name,@value 必须是长度相等的非空数组,<br>
返回 List 对象的每个元素都具有 Name,Value 属性，<br>
其值由 @names,@values 参数按数组索引顺序分配</p>

<p><a id="dotNetAppDomainObject.createWebService"></a></p>

<h3>dotNetAppDomainObject.createWebService</h3>

<p>创建 Web 服务程序集</p>

<p><a id="dotNetAppDomainObject.createWebService"></a></p>

<h3>dotNetAppDomainObject.createWebService()</h3>

<p><a href="#dotNetCrlAssemblyObject">返回对象:dotNetCrlAssemblyObject</a></p>

<p><a id="dotNetAppDomainObject.createWebService"></a></p>

<h3>dotNetAppDomainObject.createWebService(服务网址,名字空间,协议名,DLL路径)</h3>

<p>创建 Web 服务程序集,可选在参数@2中指定一个自定义的名字空间<br>
协议名默认为&quot;Soap&quot;,可选值&quot;Soap12&quot;,<br>
如果使用参数@4指定输出DLL路径则在内存中编译程序集</p>

<p><a id="dotNetAppDomainObject.delegate"></a></p>

<h3>dotNetAppDomainObject.delegate</h3>

<p>用于操作 .NET 委托（Delegate）或事件（event），<br>
在 .NET 里函数要转换为委托对象才能作为回调函数传输，<br>
在 aardio 里对所有 .NET 对象的委托字段直接赋值总是覆盖而不是追加，<br>
对所有 .NET 事件赋值时总是追加而不是覆盖，  </p>

<p><a href="#dotNetDelegateObject">返回对象:dotNetDelegateObject</a></p>

<p><a id="dotNetAppDomainObject.dict"></a></p>

<h3>dotNetAppDomainObject.dict</h3>

<p>将非空表转换为 .NET 字典。<br>
如果要创建空字典，调用返回对象的 Clear 函数清空即可。<br>
返回对象支持用下标操作符访问键值对。<br>
可用 dotNet.each 遍历字典。</p>

<p><a id="dotNetAppDomainObject.dict"></a></p>

<h3>dotNetAppDomainObject.dict()</h3>

<p><a href="#NetDictionaryObject">返回对象:NetDictionaryObject</a></p>

<p><a id="dotNetAppDomainObject.dict"></a></p>

<h3>dotNetAppDomainObject.dict(tab,byRef)</h3>

<p>将非空表转换为 .NET 字典（Dictionary）对象。  </p>

<p>如果传入空表或 null 返回 null 值。<br>
否则必须传入非空表，表中所有的键必须是相同类型。<br>
表中所有的值必须是相同类型。  </p>

<p>参数 @byRef 为可选参数，如果 @byRef 为 true，<br>
则返回对象可作为 .NET 输出与引用参数使用</p>

<p><a id="dotNetAppDomainObject.double"></a></p>

<h3>dotNetAppDomainObject.double</h3>

<p>创建 .NET System.Double 类型数值或数组</p>

<p><a id="dotNetAppDomainObject.double"></a></p>

<h3>dotNetAppDomainObject.double(value,byRef)</h3>

<p>创建 .NET System.Double 类型数值或数组，<br>
用于存储64位浮点数。  </p>

<p>参数 @value 可以为数值或数组，<br>
参数 @byRef 为 true 则支持 .NET 的输出或引用参数,  </p>

<p>注意普通数值传入 .NET 函数时，<br>
整数默认转为32位整数,小数默认按double类型处理</p>

<p><a id="dotNetAppDomainObject.each"></a></p>

<h3>dotNetAppDomainObject.each(netObj)</h3>

<pre><code class="aardio language-aardio">for i,v in dotNetAppDomainObject.each(/*输入需要遍历的 .NET 对象或普通数组，  
返回值 i 为当前索引,v 为当前值，  
注意并非所有 .NET 类型都支持此接口*/) {

}
</code></pre>

<p><a id="dotNetAppDomainObject.float"></a></p>

<h3>dotNetAppDomainObject.float</h3>

<p>创建 .NET System.Single 类型数值或数组</p>

<p><a id="dotNetAppDomainObject.float"></a></p>

<h3>dotNetAppDomainObject.float(value,byRef)</h3>

<p>创建 .NET System.Single 类型数值或数组，<br>
用于存储32位浮点数。  </p>

<p>参数 @value 可以为数值或数组，<br>
参数 @byRef 为 true 则支持 .NET 的输出或引用参数</p>

<p><a id="dotNetAppDomainObject.getInstanceMember"></a></p>

<h3>dotNetAppDomainObject.getInstanceMember(目标对象,&quot;字段名&quot;)</h3>

<p>获取对象字段或属性<br>
失败返回空值,以及错误信息</p>

<p><a id="dotNetAppDomainObject.getStaticMember"></a></p>

<h3>dotNetAppDomainObject.getStaticMember(程序集,&quot;类型名.字段名&quot;)</h3>

<p>参数一可以是程序集对象,名称或路径都可以,<br>
获取静态字段、属性值、枚举值等。</p>

<p><a id="dotNetAppDomainObject.id"></a></p>

<h3>dotNetAppDomainObject.id</h3>

<p>应用程序域 ID\</p>

<p><a id="dotNetAppDomainObject.import"></a></p>

<h3>dotNetAppDomainObject.import</h3>

<p>加载程序集，导入 .NET 名字空间、类、枚举。<br>
在当前应用程序域 import,load 等函数不会导入重复的程序集，<br>
同一程序集中不会重复导入相同的名字空间。   </p>

<p>如果已存在同名的全局名字空间但元表为空（并未导入 .NET 名字空间），<br>
则导入 .NET 名字空间到已存在的名字空间。  </p>

<p>如果已存在同名的全局名字空间但元表非空（通常为已导入的  .NET 名字空间 ），<br>
则不会覆盖已存在的名字间，而是在返回值返回当前调用实际创建的名字空间。<br>
加载程序集或依赖程序集失败时此函数会抛出异常。</p>

<p><a id="dotNetAppDomainObject.import"></a></p>

<h3>dotNetAppDomainObject.import()</h3>

<p><a href="appDomain.html#dotNetNameSpaceObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/dotNet/appDomain.html#dotNetNameSpaceObject">返回对象:dotNetNameSpaceObject</a></p>

<p><a id="dotNetAppDomainObject.import"></a></p>

<h3>dotNetAppDomainObject.import(名字空间)</h3>

<p>加载参数 @1 指定文件名的程序集，并导入同名的 .NET 名字空间或类。<br>
当程序集文件名与导入名字相同时，可以省略 指定程序集名称的参数 @2。  </p>

<p>返回名字空间可作为类构造函数调用并创建对象。<br>
也可以用成员操作符获取静态成员，或调用静态函数。  </p>

<p>导入的 .NET 名字空间在正常访问其成员时会触发元方法以获取并创建下级名字空间、类、枚举等。<br>
但导入名字空间的函数（以及 namespace 语句）创建的上级名字空间并不会主动导入同名 .NET 名字空间\。  </p>

<p>此函数会尽可能重用已存在的 aardio 全局名字空间导入 .NET 名字空间。<br>
如果该全局名字空间已导入其他 .NET 名字空间则不会覆盖已存在的名空间。<br>
此函数总是会返回当前调用实际创建的名字空间。</p>

<p><a id="dotNetAppDomainObject.import"></a></p>

<h3>dotNetAppDomainObject.import(名字空间,程序集名)</h3>

<p>加载参数@2指定文件名字的程序集。<br>
将 参数@1 指定的空间、类、枚举等导入 aardio 全局名字空间。<br>
必须指定完整名字空间。<br>
参数 @1 可指定名字空间也可以指定要导入的名字空间数组。  </p>

<p>在当前应用程序域 import,load 等函数不会导入重复的程序集，<br>
同一程序集中不会重复导入相同的名字空间。   </p>

<p>返回名字空间可作为类构造函数调用并创建对象。<br>
也可以用成员操作符返回静态成员，或调用静态函数。  </p>

<p>导入的 .NET 名字空间在正常访问其成员时会触发元方法以获取并创建下级名字空间、类、枚举等。<br>
但导入名字空间的函数（以及 namespace 语句）创建的上级名字空间并不会主动导入同名 .NET 名字空间。  </p>

<p>此函数会尽可能重用已存在的 aardio 全局名字空间导入 .NET 名字空间。<br>
如果该全局名字空间已导入其他 .NET 名字空间则不会覆盖已存在的名空间。<br>
此函数总是会返回当前调用实际创建的名字空间</p>

<p><a id="dotNetAppDomainObject.int"></a></p>

<h3>dotNetAppDomainObject.int</h3>

<p>创建 .NET System.Int32 类型数值或数组</p>

<p><a id="dotNetAppDomainObject.int"></a></p>

<h3>dotNetAppDomainObject.int(value,byRef)</h3>

<p>创建 .NET System.Int32 类型数值或数组，<br>
用于存储32位整数。  </p>

<p>参数 @value 可以为数值或数组，<br>
参数 @byRef 为 true 则支持 .NET 的输出或引用参数,  </p>

<p>注意普通数值传入 .NET 函数时，<br>
整数默认转为32位整数,小数默认按double类型处理</p>

<p><a id="dotNetAppDomainObject.interop"></a></p>

<h3>dotNetAppDomainObject.interop</h3>

<p>aardio.Interop.dll 程序集  </p>

<p><a href="#dotNetCrlAssemblyObject">返回对象:dotNetCrlAssemblyObject</a></p>

<p><a id="dotNetAppDomainObject.invokeInstanceMember"></a></p>

<h3>dotNetAppDomainObject.invokeInstanceMember(目标对象,&quot;方法名&quot;,其他调用参数)</h3>

<p>调用类的成员方法,支持传入多个调用参数并返回值<br>
失败返回空值,以及错误信息</p>

<p><a id="dotNetAppDomainObject.invokeMember"></a></p>

<h3>dotNetAppDomainObject.invokeMember(程序集,&quot;类名&quot;,&quot;方法名&quot;,BindingFlags,目标对象,其他调用参数)</h3>

<p>调用类方法,目标对象可省略,<br>
失败返回空值,以及错误信息</p>

<p><a id="dotNetAppDomainObject.invokeStaticMember"></a></p>

<h3>dotNetAppDomainObject.invokeStaticMember(程序集,&quot;类型名.方法名&quot;,其他调用参数)</h3>

<p>参数一可以是程序集对象,名称或路径都可以,<br>
调用类的静态方法,支持传入多个调用参数并返回值。<br>
失败返回空值,以及错误信息</p>

<p><a id="dotNetAppDomainObject.load"></a></p>

<h3>dotNetAppDomainObject.load</h3>

<p>使用当前线程默认应用程序域载入并返回程序集（DLL）。<br>
在当前应用程序域如果已使用此函数导入同名程序集，<br>
则直接返回该程序集</p>

<p><a id="dotNetAppDomainObject.load"></a></p>

<h3>dotNetAppDomainObject.load(&quot;程序集名&quot;)</h3>

<p>使用当前线程默认应用程序域载入并返回程序集。<br>
参数可以是程序集（DLL）名称或路径。  </p>

<p>此函数会按以下顺序调用 .NET 函数尝试加载程序集：<br>
└── Assembly.LoadWithPartialName<br>
└── Assembly.Load<br>
└── Assembly.LoadFrom<br>
└── Assembly.LoadFile</p>

<p><a id="dotNetAppDomainObject.load"></a></p>

<h3>dotNetAppDomainObject.load(&quot;程序集名&quot;,虚拟程序集数据或路径)</h3>

<p>首先在『虚拟程序集引用表』中注册程序集名，<br>
参数 @2 指定对应的内存 DLL 数据或 DLL 路径（支持 EXE 内嵌资源）。<br>
然后再调用 load 函数加载并返回该虚拟程序集</p>

<p><a id="dotNetAppDomainObject.load"></a></p>

<h3>dotNetAppDomainObject.load()</h3>

<p><a href="#dotNetCrlAssemblyObject">返回对象:dotNetCrlAssemblyObject</a></p>

<p><a id="dotNetAppDomainObject.loadAppData"></a></p>

<h3>dotNetAppDomainObject.loadAppData</h3>

<p>可用于嵌入并自 %appData% 目录加载<br>
不支持通过 loadFile 函数内存加载的程序集</p>

<p><a id="dotNetAppDomainObject.loadAppData"></a></p>

<h3>dotNetAppDomainObject.loadAppData()</h3>

<p><a href="#dotNetCrlAssemblyObject">返回对象:dotNetCrlAssemblyObject</a></p>

<p><a id="dotNetAppDomainObject.loadAppData"></a></p>

<h3>dotNetAppDomainObject.loadAppData(path,data)</h3>

<p>用 @path 指定 %appData% 目录下的相对路径,<br>
将 @data 参数指定的内存程序集数据释放到该路径,<br>
并使用 load 函数加载此程序集,<br>
@data 参数应在路径前加$符号使文件数据嵌入到代码中</p>

<p><a id="dotNetAppDomainObject.loadFile"></a></p>

<h3>dotNetAppDomainObject.loadFile</h3>

<p>使用当前线程默认应用程序域载入程序集（DLL）。<br>
参数可以是 DLL 路径，内存 DLL，或 EXE 内嵌资源。<br>
此函数并不支持 『虚拟程序集引用表』，无法在内存添加依赖 DLL<br>
程序集如果引用了自身路径必须改用 load 函数加载</p>

<p><a id="dotNetAppDomainObject.loadFile"></a></p>

<h3>dotNetAppDomainObject.loadFile(&quot;程序集路径&quot;)</h3>

<p>使用当前线程默认应用程序域载入程序集,<br>
参数可以是 DLL 路径，内存 DLL，或 EXE 内嵌资源。  </p>

<p>在路径字符串前加$符号可将文件编译并嵌入 aardio 代码,<br>
可选在第2个参数中指定pdb调试数据或pdb调试文件路径</p>

<p><a id="dotNetAppDomainObject.loadFile"></a></p>

<h3>dotNetAppDomainObject.loadFile()</h3>

<p><a href="#dotNetCrlAssemblyObject">返回对象:dotNetCrlAssemblyObject</a></p>

<p><a id="dotNetAppDomainObject.long"></a></p>

<h3>dotNetAppDomainObject.long</h3>

<p>创建 .NET System.Int64 类型数值或数组</p>

<p><a id="dotNetAppDomainObject.long"></a></p>

<h3>dotNetAppDomainObject.long(value,byRef)</h3>

<p>创建 .NET System.Int64 类型数值或数组，<br>
用于存储64位整数。  </p>

<p>参数 @value 可以为数值或数组，<br>
参数 @byRef 为 true 则支持 .NET 的输出或引用参数</p>

<p><a id="dotNetAppDomainObject.object"></a></p>

<h3>dotNetAppDomainObject.object</h3>

<p>转换参数 @1 指定的 aardio 值或数组为 .NET 原生 DispatchableObject 对象，<br>
并返回为 aardio 可操作的 dotNet.object 对象。  </p>

<p>也可用于转换 原生 .NET 对象为 dotNet.object ，<br>
或转换 dotNet.object 为支持引用 dotNet.object。  </p>

<p>dotNet.object 如果存储的是 Primitive,enum,string 类型或这些类型的数组，<br>
则可以使用 Value 属性读写值。  </p>

<p>dotnet.object 对象支持用 tostring 转换为字符串，<br>
如果存储的是数值则支持调用 tonumber 函数转为普通数值。</p>

<p><a id="dotNetAppDomainObject.object"></a></p>

<h3>dotNetAppDomainObject.object(value,byRef)</h3>

<p>参数 @byRef 为 true 则支持 .NET 的输出或引用参数  </p>

<p>参数 @value 如果指定纯 aardio 对象或数组。<br>
则转换为 .NET 原生 DispatchableObject 对象，并封装为 dotNet.object 后返回。  </p>

<p>如果参数 @1 指定 dotNet.object 对象且参数 @2 不为 true 则直接返回。<br>
如果参数传入原生 .NET 对象且参数 @2 不为 true 则仅转换为 dotNet.object。<br>
如果参数 @2 为 true，则这些对象都会转换为 DispatchableObject 并返回新的 dotNet.object</p>

<p><a id="dotNetAppDomainObject.reference"></a></p>

<h3>dotNetAppDomainObject.reference</h3>

<p>在『虚拟程序集引用表』注册一个或多个虚拟程序集，<br>
这些虚拟程序集可以是内存程序集、本地程序集、EXE 内嵌资源中的程序集。  </p>

<p>aardio 加载的 .NET 程序找不到程序集（DLL）时，<br>
会查找『虚拟程序集引用表』并加载已注册的虚拟 DLL</p>

<p><a id="dotNetAppDomainObject.reference"></a></p>

<h3>dotNetAppDomainObject.reference(assemblyName2pathOrData)</h3>

<p>在『虚拟程序集引用表』注册多个虚拟程序集（DLL）。<br>
@assemblyName2pathOrData 指定一个表：<br>
表的「键」为虚拟程序集短名称（ DLL 文件名 ），  </p>

<p>键对应的「值」指定程序集内存数据或程序集路径（支持内嵌资源）</p>

<p><a id="dotNetAppDomainObject.reference"></a></p>

<h3>dotNetAppDomainObject.reference(simpleAssemblyName,pathOrData)</h3>

<p>在『虚拟程序集引用表』注册虚拟程序集（DLL）。<br>
@simpleAssemblyName 指定程序集短名称（虚拟 DLL 文件名）<br>
@pathOrData 指定程序集路径或内存数据，支持内嵌资源路径<br>
@pathOrData 也可以是返回程序集路径或数据的回调函数</p>

<p><a id="dotNetAppDomainObject.setInstanceMember"></a></p>

<h3>dotNetAppDomainObject.setInstanceMember(目标对象,&quot;字段名&quot;,值)</h3>

<p>设置对象实例的字段或属性<br>
成功返回 true ,失败返回空值,以及错误信息</p>

<p><a id="dotNetAppDomainObject.ubyte"></a></p>

<h3>dotNetAppDomainObject.ubyte</h3>

<p>创建 .NET System.Byte 类型数值或数组</p>

<p><a id="dotNetAppDomainObject.ubyte"></a></p>

<h3>dotNetAppDomainObject.ubyte(value,byRef)</h3>

<p>创建 .NET System.Byte 类型数值或数组，<br>
用于存储8位无符号整数。  </p>

<p>参数 @value 可以为数值或数组，<br>
参数 @byRef 为 true 则支持 .NET 的输出或引用参数</p>

<p><a id="dotNetAppDomainObject.uint"></a></p>

<h3>dotNetAppDomainObject.uint</h3>

<p>创建 .NET System.UInt32 类型数值或数组</p>

<p><a id="dotNetAppDomainObject.uint"></a></p>

<h3>dotNetAppDomainObject.uint(value,byRef)</h3>

<p>创建 .NET System.UInt32 类型数值或数组，<br>
用于存储32位无符号整数。  </p>

<p>参数 @value 可以为数值或数组，<br>
参数 @byRef 为 true 则支持 .NET 的输出或引用参数</p>

<p><a id="dotNetAppDomainObject.ulong"></a></p>

<h3>dotNetAppDomainObject.ulong</h3>

<p>创建 .NET System.UInt64 类型数值或数组</p>

<p><a id="dotNetAppDomainObject.ulong"></a></p>

<h3>dotNetAppDomainObject.ulong(value,byRef)</h3>

<p>创建 .NET System.UInt64 类型数值或数组，<br>
用于存储64位无符号整数。  </p>

<p>参数 @value 可以为数值或数组，<br>
参数 @byRef 为 true 则支持 .NET 的输出或引用参数</p>

<p><a id="dotNetAppDomainObject.unload"></a></p>

<h3>dotNetAppDomainObject.unload()</h3>

<p>卸载应用程序域,一般不需要手动调用此函数,<br>
当前线程退出时会自动释放此线程创建的所有应用程序域,<br>
不带参数调用 dotNet.appDomain 创建的应用程序域不应手动调用此函数释放</p>

<p><a id="dotNetAppDomainObject.utility"></a></p>

<h3>dotNetAppDomainObject.utility</h3>

<p>aardio.Interop.Utility 对象</p>

<p><a id="dotNetAppDomainObject.uword"></a></p>

<h3>dotNetAppDomainObject.uword</h3>

<p>创建 .NET System.UInt16 类型数值或数组</p>

<p><a id="dotNetAppDomainObject.uword"></a></p>

<h3>dotNetAppDomainObject.uword(value,byRef)</h3>

<p>创建 .NET System.UInt16 类型数值或数组，<br>
用于存储16位无符号整数。  </p>

<p>参数 @value 可以为数值或数组，<br>
参数 @byRef 为 true 则支持 .NET 的输出或引用参数</p>

<p><a id="dotNetAppDomainObject.word"></a></p>

<h3>dotNetAppDomainObject.word</h3>

<p>创建 .NET System.Int16 类型数值或数组</p>

<p><a id="dotNetAppDomainObject.word"></a></p>

<h3>dotNetAppDomainObject.word(value,byRef)</h3>

<p>创建 .NET System.Int16 类型数值或数组，<br>
用于存储16位整数。  </p>

<p>参数 @value 可以为数值或数组，<br>
参数 @byRef 为 true 则支持 .NET 的输出或引用参数</p>

<p><a id="dotNetAppDomainObject.wrapObject"></a></p>

<h3>dotNetAppDomainObject.wrapObject()</h3>

<p>如参数是原生 .NET 对象,则返回 dotNet.object 对象，否则直接返回参数。  </p>

<p>所有 .NET 原生对象已经自动转换为 dotNet.object 对象，<br>
除非 .NET 调用普通 aardio 对象的成员函数而非回调特定的委托或事件函数。<br>
这时候回调参数中的 .NET 对象需要用此函数转换，但数值和字符串不需要转换。  </p>

<p>参数传入 com.IsNetObject 函数会返回非 0 值即为原生 .NET 对象，<br>
非原生 .NET 对象转换为 dotNet.object 应当直接调用 dotNet.object 函数。</p>

<p><a id="dotNetCompilerObject"></a></p>

<h2>dotNetCompilerObject 成员列表</h2>

<p><a id="dotNetCompilerObject.Compile"></a></p>

<h3>dotNetCompilerObject.Compile</h3>

<p>编译并返回程序集</p>

<p><a id="dotNetCompilerObject.Compile"></a></p>

<h3>dotNetCompilerObject.Compile()</h3>

<p><a href="#dotNetCrlAssemblyObject">返回对象:dotNetCrlAssemblyObject</a></p>

<p><a id="dotNetCompilerObject.Compile"></a></p>

<h3>dotNetCompilerObject.Compile(outpath)</h3>

<p>编译并返回程序集,所有参数可选,<br>
如果参数 @outpath 指定了输出 dll 或 exe 文件路径，则输出为文件,<br>
遇到错误不会抛出异常，请调用 getLastError 函数获取错误信息</p>

<p><a id="dotNetCompilerObject.CompileOrFail"></a></p>

<h3>dotNetCompilerObject.CompileOrFail</h3>

<p>编译并返回程序集</p>

<p><a id="dotNetCompilerObject.CompileOrFail"></a></p>

<h3>dotNetCompilerObject.CompileOrFail()</h3>

<p><a href="#dotNetCrlAssemblyObject">返回对象:dotNetCrlAssemblyObject</a></p>

<p><a id="dotNetCompilerObject.CompileOrFail"></a></p>

<h3>dotNetCompilerObject.CompileOrFail(outpath)</h3>

<p>编译并返回程序集,所有参数可选,<br>
如果参数 @outpath 指定了输出 dll 或 exe 文件路径，则输出为文件,<br>
遇到错误会抛出异常</p>

<p><a id="dotNetCompilerObject.Reference"></a></p>

<h3>dotNetCompilerObject.Reference</h3>

<p>引用程序集，System.dll 已默认添加  </p>

<p>注意这函数不支持内存 DLL，<br>
也不支持用 dotNet.reference 添加的内存 DLL。</p>

<p><a id="dotNetCompilerObject.Reference"></a></p>

<h3>dotNetCompilerObject.Reference(assemblyDir,subPath...)</h3>

<p>引用程序集,<br>
参数@1指定目录,可指定一个或多个子路径,<br>
使用 io.joinpath 函数合并参数转换为完整路径,<br>
然后引用该程序集。</p>

<p><a id="dotNetCompilerObject.Reference"></a></p>

<h3>dotNetCompilerObject.Reference(assemblyPath,...)</h3>

<p>引用程序集,<br>
可指定任意多个程序集路径或名称参数,<br>
如果指定不含 dll 后缀名的程序集名，则加载程序集并转换为完整路径。</p>

<p><a id="dotNetCompilerObject.Source"></a></p>

<h3>dotNetCompilerObject.Source</h3>

<pre><code class="aardio language-aardio">dotNetCompilerObject.Source = /***  
using System;  

namespace CSharpLibrary    
{  
    public class NetObject    
    {  
        public NetObject()  
        {  
            /*Source 属性可用字符串或字符串数组指定要编辑的代码。  
如果指定字符串则启用 aardio 模板语法，如果代码开始没有模板标记则自动添加。  
编译器对象的 ownerArgs 属性指定模板 owner 参数。  
CLR v2.0 / v4.0 可运行在 3.x,4.x 编译的 DLL，但编译器仅支持 CLR 相同版本语法。  
如果要添加文件，请改用 addSource 函数。*/  
        }   
    }  
}   
***/
</code></pre>

<p><a id="dotNetCompilerObject.addSource"></a></p>

<h3>dotNetCompilerObject.addSource</h3>

<p>添加源码，使用此函数添加源码后 Source 属性将变为数组</p>

<p><a id="dotNetCompilerObject.addSource"></a></p>

<h3>dotNetCompilerObject.addSource(code,rep)</h3>

<p>参数 @code 可以指定代码或代码文件路径。<br>
可指定嵌入资源路径，源文件必须使用 UTF-8 编码。<br>
如果代码开始的非空白空字为 &lt;? 或  ?&gt; 则启用 aardio 模板语法，<br>
编译器对象的 ownerArgs 属性指定模板 owner 参数。<br>
参数 @rep 指定是否丢弃之前添加的代码</p>

<p><a id="dotNetCompilerObject.defaultSource"></a></p>

<h3>dotNetCompilerObject.defaultSource</h3>

<p>编译前默认添加到前面的代码</p>

<p><a id="dotNetCompilerObject.getLastError"></a></p>

<h3>dotNetCompilerObject.getLastError()</h3>

<p>获取编译错误信息</p>

<p><a id="dotNetCompilerObject.getProvider"></a></p>

<h3>dotNetCompilerObject.getProvider()</h3>

<p>编译器</p>

<p><a id="dotNetCompilerObject.import"></a></p>

<h3>dotNetCompilerObject.import</h3>

<p>编译代码生成程序集，遇到错误会抛出异常。<br>
将 参数@1指定的名字空间或类导入 aardio 全局名字空间。<br>
在同一程序集中不会重复导入名字空间。  </p>

<p>如果程序集用不是用 load 函数加载，则有可能重复导入名字空间,<br>
重复导入 .NET 名字空间不会修改已存在的全局名字空间，<br>
但此函数总是会返回当前调用实际创建的名字空间</p>

<p><a id="dotNetCompilerObject.import"></a></p>

<h3>dotNetCompilerObject.import()</h3>

<p><a href="appDomain.html#dotNetNameSpaceObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/dotNet/appDomain.html#dotNetNameSpaceObject">返回对象:dotNetNameSpaceObject</a></p>

<p><a id="dotNetCompilerObject.import"></a></p>

<h3>dotNetCompilerObject.import(netNamespace)</h3>

<p>编译代码生成程序集，遇到错误会抛出异常。<br>
将 参数@1指定的名字空间或类导入 aardio 全局名字空间。<br>
必须指定完整名字空间,不传入参数则默认指定参数为程序集名称。  </p>

<p>返回名字空间可作为类构造函数调用并创建对象<br>
也可以用成员操作符返回静态成员，或调用静态函数。  </p>

<p>重复导入 .NET 名字空间不会修改已存在的全局名字空间，<br>
但此函数总是会返回当前调用实际创建的名字空间</p>

<p><a id="dotNetCompilerObject.loadcode"></a></p>

<h3>dotNetCompilerObject.loadcode</h3>

<p>用于自定义板解析函数，<br>
用于解析启用 aardio 模板语法的 C&num; 代码。<br>
默认指向 string.loadcode 。</p>

<p><a id="dotNetCompilerObject.ownerArgs"></a></p>

<h3>dotNetCompilerObject.ownerArgs</h3>

<p>模板语法使用的 owner 参数，默认为表对象。</p>

<p><a id="dotNetCompilerObject.Parameters"></a></p>

<h2>dotNetCompilerObject.Parameters 成员列表</h2>

<p>编译参数</p>

<p><a id="dotNetCompilerObject.Parameters.CompilerOptions"></a></p>

<h3>dotNetCompilerObject.Parameters.CompilerOptions</h3>

<pre><code class="aardio language-aardio">dotNetCompilerObject.Parameters.CompilerOptions = &quot;/optimize /unsafe&quot;/*编译参数，/optimize 为开启优化*/
</code></pre>

<p><a id="dotNetCompilerObject.Parameters.GenerateExecutable"></a></p>

<h3>dotNetCompilerObject.Parameters.GenerateExecutable</h3>

<p>是否编译为EXE执行文件<br>
编译为DLL设为false</p>

<p><a id="dotNetCompilerObject.Parameters.GenerateInMemory"></a></p>

<h3>dotNetCompilerObject.Parameters.GenerateInMemory</h3>

<p>是否内存编译</p>

<p><a id="dotNetCompilerObject.Parameters.OutputAssembly"></a></p>

<h3>dotNetCompilerObject.Parameters.OutputAssembly</h3>

<p>指定输出文件路径,<br>
参数需要调用io.fullpath()转换为绝对路径,<br>
需要设GenerateInMemory为false取消内存编译,<br>
调用setGenerateExecutable指定编译为DLL或者EXE</p>

<p><a id="dotNetCrlArrayListObject"></a></p>

<h2>dotNetCrlArrayListObject 成员列表</h2>

<p><a id="dotNetCrlArrayListObject.Add"></a></p>

<h3>dotNetCrlArrayListObject.Add(添加对象)</h3>

<p>添加成员到数组中</p>

<p><a id="dotNetCrlArrayListObject.Clear"></a></p>

<h3>dotNetCrlArrayListObject.Clear()</h3>

<p>添空数组</p>

<p><a id="dotNetCrlArrayListObject.ToArray"></a></p>

<h3>dotNetCrlArrayListObject.ToArray()</h3>

<p>转换并返回数组</p>

<p><a id="dotNetCrlArrayListObject.ToList"></a></p>

<h3>dotNetCrlArrayListObject.ToList()</h3>

<p>转换并返回 List 对象</p>

<p><a id="dotNetCrlAssemblyObject"></a></p>

<h2>dotNetCrlAssemblyObject 成员列表</h2>

<p><a id="dotNetCrlAssemblyObject.FullName"></a></p>

<h3>dotNetCrlAssemblyObject.FullName</h3>

<p>获取程序集的全名</p>

<p><a id="dotNetCrlAssemblyObject.Location"></a></p>

<h3>dotNetCrlAssemblyObject.Location</h3>

<p>获取完整路径</p>

<p><a id="dotNetCrlAssemblyObject.appDomain"></a></p>

<h3>dotNetCrlAssemblyObject.appDomain</h3>

<p>加载此程序集的应用程序域  </p>

<p><a href="#dotNetAppDomainObject">返回对象:dotNetAppDomainObject</a></p>

<p><a id="dotNetCrlAssemblyObject.getStaticMember"></a></p>

<h3>dotNetCrlAssemblyObject.getStaticMember(&quot;类名.字段名&quot;)</h3>

<p>获取字段或属性值、或枚举值</p>

<p><a id="dotNetCrlAssemblyObject.import"></a></p>

<h3>dotNetCrlAssemblyObject.import</h3>

<p>将 .NET 类名或名字空间导入 aardio 全局名字空间。<br>
在当前应用程序域 import,load 等函数不会导入重复的程序集，<br>
在同一程序集中不会重复导入名字空间。  </p>

<p>如果程序集用其他函数加载，则有可能重复导入名字空间,<br>
重复导入 .NET 名字空间不会修改已存在的全局名字空间，<br>
但此函数总是会返回当前调用实际创建的名字空间</p>

<p><a id="dotNetCrlAssemblyObject.import"></a></p>

<h3>dotNetCrlAssemblyObject.import(netNamespace)</h3>

<p>将参数@1 指定的 .NET 类名或名字空间导入 aardio 全局名字空间，<br>
必须指定完整名字空间。<br>
参数 @1 可指定名字空间也可以指定要导入的名字空间数组。<br>
不传入参数则默认指定参数为程序集名称。  </p>

<p>返回名字空间可作为类构造函数调用并创建对象<br>
也可以用成员操作符返回静态成员，或调用静态函数。  </p>

<p>重复导入 .NET 名字空间不会修改已存在的全局名字空间，<br>
但此函数总是会返回当前调用实际创建的名字空间</p>

<p><a id="dotNetCrlAssemblyObject.import"></a></p>

<h3>dotNetCrlAssemblyObject.import(netNamespace,...)</h3>

<p>参数@1 指定要导入的 .NET 类名。<br>
如果再指定一个或多个类型参数时则导入泛型类。<br>
类型参数可以是导入的 .NET 类、类名全称、System.Type.GetType 获取的类型对象。<br>
对导入的 .NET 类使用下标 [&quot;&lt;&gt;&quot;] 也可以返回一个创建泛型类的函数。<br>
泛型类不会缓存，也不会设为 aardio 全局名字空间</p>

<p><a id="dotNetCrlAssemblyObject.invokeStaticMember"></a></p>

<h3>dotNetCrlAssemblyObject.invokeStaticMember(&quot;类名.方法名&quot;,... )</h3>

<p>调用类的静态方法,<br>
可添加不定个数调用参数<br>
失败返回空值,以及错误信息</p>

<p><a id="dotNetCrlAssemblyObject.new"></a></p>

<h3>dotNetCrlAssemblyObject.new(&quot;类名&quot;,... )</h3>

<p>创建对象实例,<br>
可添加不定个数构造参数<br>
失败返回空值,以及错误信息</p>

<p><a id="dotNetDelegateObject"></a></p>

<h2>dotNetDelegateObject 成员列表</h2>

<p><a id="dotNetDelegateObject.combine"></a></p>

<h3>dotNetDelegateObject.combine</h3>

<p>合并委托<br>
在 .NET 里函数要转换为委托对象才能作为回调函数传输</p>

<p><a id="dotNetDelegateObject.combine"></a></p>

<h3>dotNetDelegateObject.combine(委托对象1,委托对象2)</h3>

<p>返回合并的委托对象,允许省略所有参数，<br>
如果指定参数则至少有一个 .NET 委托对象，<br>
另一个参数可以是委托对象，也可指定普通 aardio 函数或表,<br>
如果是普通 aardio 表则回调 _call 元方法,<br>
aardio 函数或表参数会自动转换为所需类型的 .NET 委托</p>

<p><a id="dotNetDelegateObject.combine"></a></p>

<h3>dotNetDelegateObject.combine(对象,委托成员名,委托对象)</h3>

<p>自参数@1指定的 .NET 对象中查询参数 @2指定的的属性或字段,<br>
如果该成员是一个 delegate 或 event 类型，则合并参数@2，@3指定的委托并更新该成员的值。<br>
原委托成员可为空值，但参数@1,@2 不可省略。  </p>

<p>参数 @3 可指定 .NET 委托对象、null 值或省略。<br>
如果参数 @3 是普通的 aardio 函数或表则转换为所需类型的 .NET 委托。<br>
此函数返回参数@3创建的委托对象,可用于 remove 函数.</p>

<p><a id="dotNetDelegateObject.create"></a></p>

<h3>dotNetDelegateObject.create</h3>

<p>创建委托<br>
在 .NET 里函数要转换为委托对象才能作为回调函数传输</p>

<p><a id="dotNetDelegateObject.create"></a></p>

<h3>dotNetDelegateObject.create(对象,委托成员名,函数对象)</h3>

<p>自参数@1指定的 .NET 对象中查询参数 @2指定的的属性或字段,<br>
如果该成员是一个 delegate 或 event 类型，<br>
则将@3指定的函数转换为该类型的委托对象并返回</p>

<p><a id="dotNetDelegateObject.list"></a></p>

<h3>dotNetDelegateObject.list()</h3>

<p>返回参数 @1 指定委托对象的调用对象列表,<br>
相当于调用委托对象的 GetInvocationList 函数。</p>

<p><a id="dotNetDelegateObject.remove"></a></p>

<h3>dotNetDelegateObject.remove</h3>

<p>移除委托</p>

<p><a id="dotNetDelegateObject.remove"></a></p>

<h3>dotNetDelegateObject.remove(委托对象1,委托对象2)</h3>

<p>自参数@1指定的委托中移除以参数@2指定的委托，<br>
所有参数必须是 .NET 委托对象,<br>
成功返回新的委托，<br>
失败或委托调用链没有变化返回 null,<br>
任何一个参数为 null 返回 null</p>

<p><a id="dotNetDelegateObject.remove"></a></p>

<h3>dotNetDelegateObject.remove(对象,委托成员名,委托对象)</h3>

<p>自参数@1指定的 .NET 对象中查询参数 @2指定的的属性或字段,<br>
如果该成员是一个 delegate 或 event 类型，则移除参数@3指定的委托并更新该成员的值。<br>
原委托成员可为空值，但参数@1,@2 不可省略。  </p>

<p>参数 @3 指定需要移除的 .NET 委托对象。<br>
不指定参数 @3 则不执行任何操作。<br>
移除成功返回 true，失败返回 false</p>

<p><a id="dotNetNameSpaceObject"></a></p>

<h2>dotNetNameSpaceObject 成员列表</h2>

<p><a id="dotNetNameSpaceObject.?"></a></p>

<h3>dotNetNameSpaceObject.?</h3>

<p>.NET 名字空间、类、结构体的成员，<br>
可访问成员名字空间、类、枚举、静态属性或字段，<br>
导入的类可用于构造 .NET 对象，传回 .NET 则自动转为该类的 Type 对象。<br>
通过下标 [&quot;&lt;&gt;&quot;] 可返回一个创建泛型类的函数，函数参数为类型对象或完整类型名称。  </p>

<p><a href="appDomain.html#dotNetNameSpaceObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/dotNet/appDomain.html#dotNetNameSpaceObject">返回对象:dotNetNameSpaceObject</a></p>

<p><a id="dotNetNameSpaceObject.assembly"></a></p>

<h3>dotNetNameSpaceObject.assembly</h3>

<p>导入此 .NET 名字空间的程序集对象。  </p>

<p><a href="#dotNetCrlAssemblyObject">返回对象:dotNetCrlAssemblyObject</a></p>

<p><a href="https://www.aardio.com/zh-cn/doc/library-reference/dotNet/appDomain.md">Markdown 格式</a></p>

</body> 
</html>